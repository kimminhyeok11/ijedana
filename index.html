<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>에테르의 마지막 별</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        :root {
            --primary-accent: #a252ff; --secondary-accent: #4f46e5; --text-light: #e5e7eb;
            --text-dark: #9ca3af; --bg-dark-1: #111827; --bg-dark-2: rgba(31, 41, 55, 0.5);
            --border-color: rgba(255, 255, 255, 0.1); --error-color: #f87171;
            --combo-color: #facc15;
        }
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: var(--bg-dark-1); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; }
        #game-wrapper { position: relative; width: 100%; height: 100%; max-width: 500px; margin: 0 auto; display: flex; justify-content: center; align-items: center; background-color: var(--bg-dark-1); overflow: hidden; }
        canvas { width: 100%; height: 100%; cursor: pointer; -webkit-tap-highlight-color: transparent; image-rendering: pixelated; }
        #score-display { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); color: white; font-size: 2rem; font-weight: bold; text-shadow: 0 0 10px rgba(255, 255, 255, 0.7); z-index: 10; display: none; }
        
        #combo-display {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--combo-color);
            font-size: 1.8rem;
            font-weight: 900;
            text-shadow: 0 0 10px rgba(250, 204, 21, 0.7);
            z-index: 10;
            opacity: 0;
            pointer-events: none;
        }
        
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(17, 24, 39, 0.8); backdrop-filter: blur(8px); color: var(--text-light); display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 20; opacity: 1; visibility: visible; transition: opacity 0.5s, visibility 0.5s; padding: 20px; box-sizing: border-box; }
        .overlay.hidden { opacity: 0; visibility: hidden; }
        .overlay h2 { font-size: 2.5rem; margin: 0 0 10px 0; font-weight: 700; }
        .is-hidden { opacity: 0; }
        
        #intro-character {
            width: 84px;
            height: 141px;
            background-image: url('https://fzfnjtlzovbpbglvkroh.supabase.co/storage/v1/object/public/images/jump.webp');
            background-size: 410px 614px;
            background-position: -51px -68px;
            margin-bottom: 20px;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-15px); }
            100% { transform: translateY(0px); }
        }

        .story-blurb {
            font-size: 0.9rem;
            color: var(--text-dark);
            margin-top: -5px;
            margin-bottom: 25px;
            max-width: 280px;
        }

        #instructions { background-color: var(--bg-dark-2); padding: 15px 25px; border-radius: 12px; border: 1px solid var(--border-color); }
        .control-info { display: flex; align-items: center; justify-content: center; gap: 15px; }
        .control-info:not(:last-child) { margin-bottom: 15px; }
        .control-info span { font-size: 1.5rem; }
        .control-info p { margin: 0; font-size: 0.9rem; color: var(--text-dark); }
        
        .touch-indicator { position: absolute; top: 50%; transform: translateY(-50%); font-size: 3rem; color: rgba(255, 255, 255, 0.2); z-index: 5; pointer-events: none; opacity: 0; transition: opacity 0.3s; user-select: none; }
        .touch-indicator.visible { opacity: 1; }
        #touch-left { left: 20px; }
        #touch-right { right: 20px; }

        #gameOverScreen { justify-content: flex-start; padding-top: 2vh; overflow-y: auto; }
        #finalScore { font-size: 2.5rem; font-weight: 700; color: var(--combo-color); }
        #finalScoreLabel { font-size: 1rem; color: var(--text-dark); margin-bottom: 5px; }

        .content-wrapper { display: flex; flex-direction: column; width: 100%; max-width: 380px; gap: 15px; }
        .content-box { width: 100%; background-color: var(--bg-dark-2); border: 1px solid var(--border-color); border-radius: 16px; padding: 15px; box-sizing: border-box; text-align: left; }
        .content-box h3 { font-size: 1rem; font-weight: 600; margin: 0 0 10px 0; color: var(--text-light); }
        
        #ranking-list { list-style: none; padding: 0; margin: 0; }
        #ranking-list li { display: flex; justify-content: space-between; align-items: baseline; padding: 8px 0; font-size: 0.9rem; }
        .rank-name { color: var(--text-light); }
        .rank-score { font-weight: 600; color: var(--combo-color); }

        #guestbook-entries { max-height: 120px; overflow-y: auto; }
        .guestbook-entry { padding: 8px 0; font-size: 0.85rem; border-bottom: 1px solid var(--border-color); }
        .guestbook-entry:last-child { border-bottom: none; }
        .guestbook-entry p { margin: 0; line-height: 1.5; word-wrap: break-word; }
        .guestbook-entry strong { color: var(--primary-accent); font-weight: 600; }
        .guestbook-entry .score { font-size: 0.75rem; color: var(--text-dark); margin-left: 5px; }
        
        #more-guestbook-btn { background: none; border: 1px solid var(--border-color); color: var(--text-dark); width: 100%; padding: 8px; border-radius: 8px; margin-top: 10px; cursor: pointer; font-size: 0.85rem; }
        #more-guestbook-btn:hover { background-color: var(--border-color); }
        #more-guestbook-btn.hidden { display: none; }

        #guestbook-form { margin-top: 15px; }
        .input-group { display: flex; flex-wrap: wrap; gap: 8px; }
        #guestbook-name { flex: 1 1 80px; }
        #guestbook-message { flex: 1 1 120px; }
        #guestbook-form input { background-color: var(--bg-dark-1); border: 1px solid var(--border-color); border-radius: 8px; padding: 10px 12px; color: var(--text-light); font-size: 0.9rem; min-width: 0; }
        #guestbook-submit { background: linear-gradient(45deg, var(--secondary-accent), var(--primary-accent)); border: none; border-radius: 8px; padding: 10px 15px; color: white; font-weight: 600; font-size: 0.9rem; cursor: pointer; }
        #guestbook-submit:disabled { background: #374151; cursor: not-allowed; }
        #guestbook-error { color: var(--error-color); font-size: 0.8rem; height: 1em; text-align: left; margin-top: 5px; }

        .button-group { display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 380px; gap: 8px; margin-top: 12px; }
        .btn-style { padding: 12px; width: 100%; background-color: transparent; color: var(--text-light); text-decoration: none; border-radius: 12px; font-weight: 600; cursor: pointer; border: 1px solid var(--border-color); font-size: 0.9rem; box-sizing: border-box; transition: background-color 0.2s; text-align: center; }
        .btn-style:hover { background-color: var(--border-color); }
    </style>
</head>
<body>
<div id="game-wrapper">
    <canvas id="gameCanvas"></canvas>
    <div id="score-display">0</div>
    <div id="combo-display"></div>
    <div id="touch-left" class="touch-indicator">&lt;</div>
    <div id="touch-right" class="touch-indicator">&gt;</div>
    
    <div id="startScreen" class="overlay">
        <div id="intro-character"></div>
        <h2 id="main-title">에테르의 마지막 별</h2>
        <p class="story-blurb">길 잃은 마지막 별이 고향으로 돌아갈 수 있도록 도와주세요.</p>
        <div id="instructions">
            <div class="control-info"><span>🖥️</span><p>A / D or ← / →</p></div>
            <div class="control-info"><span>📱</span><p>Touch Left / Right</p></div>
        </div>
    </div>

    <div id="gameOverScreen" class="overlay hidden">
        <p id="finalScoreLabel" class="is-hidden">최종 점수</p>
        <p id="finalScore" class="is-hidden">0</p>
        
        <div class="content-wrapper is-hidden">
            <div id="ranking-container" class="content-box">
                <h3>명예의 전당</h3>
                <ol id="ranking-list"><p>랭킹을 불러오는 중...</p></ol>
            </div>

            <div id="guestbook-container" class="content-box">
                <h3>방명록</h3>
                <div id="guestbook-entries"><p>방명록을 불러오는 중...</p></div>
                <button id="more-guestbook-btn" class="hidden">더보기</button>
                <form id="guestbook-form">
                    <div class="input-group">
                        <input type="text" id="guestbook-name" placeholder="이름" maxlength="20" required>
                        <input type="text" id="guestbook-message" placeholder="한마디" maxlength="150" required>
                        <button type="submit" id="guestbook-submit">등록</button>
                    </div>
                    <div id="guestbook-error"></div>
                </form>
            </div>
        </div>

        <div class="button-group is-hidden">
            <button id="restartButton" class="btn-style">다시 시작</button>
            <a href="https://www.threads.net/@ilovemom_2026" target="_blank" class="btn-style">개발자 Threads 방문</a>
        </div>
    </div>
</div>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        // --- Supabase 설정 ---
        const SUPABASE_URL = 'https://fzfnjtlzovbpbglvkroh.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZ6Zm5qdGx6b3ZicGJnbHZrcm9oIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU4OTcyMjEsImV4cCI6MjA3MTQ3MzIyMX0.yg43GbdVBPAzaghmERNGxRu9dte3bcpWTWjrOa0p55I';
        let supabase = null;
        try {
            if (window.supabase && typeof window.supabase.createClient === 'function') {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            } else {
                console.error("Supabase 라이브러리가 로드되지 않았습니다.");
            }
        } catch (e) {
            console.error("Supabase 초기화 오류:", e);
        }

        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-display'); const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen'); const finalScoreEl = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton'); const rankingList = document.getElementById('ranking-list');
        const guestbookEntries = document.getElementById('guestbook-entries'); const guestbookForm = document.getElementById('guestbook-form');
        const guestbookName = document.getElementById('guestbook-name'); const guestbookMessage = document.getElementById('guestbook-message');
        const guestbookSubmit = document.getElementById('guestbook-submit'); const guestbookError = document.getElementById('guestbook-error');
        const moreGuestbookBtn = document.getElementById('more-guestbook-btn');
        const touchLeft = document.getElementById('touch-left'); const touchRight = document.getElementById('touch-right');
        const comboDisplay = document.getElementById('combo-display');

        // --- Sprite Sheet 설정 ---
        const spriteSheet = new Image();
        const backgroundSheet = new Image(); // 배경 스프라이트 시트
        let isSpriteSheetLoaded = false;
        let isBackgroundSheetLoaded = false; // 배경 스프라이트 로드 상태

        const spriteData = {
            sprites: [
                { "name": "sprite_1", "x": 128, "y": 169, "w": 209, "h": 352 },
                { "name": "sprite_2", "x": 414, "y": 170, "w": 210, "h": 355 },
                { "name": "sprite_3", "x": 688, "y": 170, "w": 208, "h": 353 },
                { "name": "sprite_4", "x": 128, "y": 605, "w": 225, "h": 355 },
                { "name": "sprite_5", "x": 400, "y": 605, "w": 225, "h": 347 },
                { "name": "sprite_6", "x": 688, "y": 605, "w": 208, "h": 355 },
                { "name": "sprite_7", "x": 147, "y": 1049, "w": 206, "h": 357 },
                { "name": "sprite_8", "x": 702, "y": 1049, "w": 200, "h": 343 },
                { "name": "sprite_9", "x": 429, "y": 1050, "w": 196, "h": 355 }
            ]
        };
        const backgroundSpriteData = {
            sprites: [
                { "name": "sprite_2", "x": 689, "y": 94, "w": 321, "h": 434 },
                { "name": "sprite_3", "x": 357, "y": 107, "w": 320, "h": 418 },
                { "name": "sprite_4", "x": 55, "y": 132, "w": 265, "h": 381 },
                { "name": "sprite_5", "x": 424, "y": 571, "w": 170, "h": 414 },
                { "name": "sprite_6", "x": 660, "y": 572, "w": 303, "h": 412 },
                { "name": "sprite_7", "x": 41, "y": 584, "w": 308, "h": 397 },
                { "name": "sprite_9", "x": 396, "y": 1036, "w": 234, "h": 400 },
                { "name": "sprite_10", "x": 704, "y": 1047, "w": 296, "h": 390 },
                { "name": "sprite_11", "x": 43, "y": 1080, "w": 302, "h": 188 }
            ]
        };

        const spriteMap = spriteData.sprites.reduce((acc, sprite) => { acc[sprite.name] = sprite; return acc; }, {});
        const animations = {
            idle: { frames: ["sprite_1", "sprite_2", "sprite_3"], speed: 15 },
            running: { frames: ["sprite_4", "sprite_5", "sprite_6", "sprite_7"], speed: 8 },
            jumping: { frames: ["sprite_8", "sprite_9"], speed: 1 }
        };

        // --- Game State & Constants ---
        let gameState = 'start', player = null, platforms = [], stars = [], moon = null, particles = [], backgroundElements = [], cameraY = 0, score = 0, baseScore = 0, bonusScore = 0, highestY = 0, finalGameScore = 0;
        let guestbookLimit = 3; let lastTime = 0; let lastMilestoneScore = 0;
        let availableBackgroundSprites = [];
        let comboCount = 0; let comboTimeout; let lastPlatform = null;
        const keys = { left: false, right: false }; const GRAVITY = 0.91, JUMP_FORCE = -19.5;
        
        // --- 배경화면 상태 ---
        let backgroundState = 0;
        const hexToRgb = (hex) => { const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null; };
        const backgrounds = [
            { top: hexToRgb('#0f0c29'), bottom: hexToRgb('#24243e') }, // 0: 지구
            { top: hexToRgb('#000033'), bottom: hexToRgb('#000000') }, // 1: 우주
            { top: hexToRgb('#4a00e0'), bottom: hexToRgb('#8e2de2') }, // 2: 제4세계
            { top: hexToRgb('#ffaf7b'), bottom: hexToRgb('#d76d77') }  // 3: 천상계
        ];
        let currentBgTop = backgrounds[0].top;
        let currentBgBottom = backgrounds[0].bottom;

        // --- Audio ---
        let isAudioReady = false; let jumpSound, gameOverSound, crumbleSound;
        function initAudio() { if(isAudioReady) return; Tone.start().then(() => { jumpSound = new Tone.Synth({oscillator:{type:'triangle'},envelope:{attack:0.005,decay:0.1,sustain:0.05,release:0.1}}).toDestination(); gameOverSound = new Tone.Synth({oscillator:{type:'sine'},envelope:{attack:0.1,decay:0.5,sustain:0.1,release:0.5}}).toDestination(); crumbleSound = new Tone.NoiseSynth({noise:{type:'brown'},envelope:{attack:0.01,decay:0.15,sustain:0,release:0.1}}).toDestination(); isAudioReady = true; }); }

        // --- Initialization & Game Loop ---
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function setCanvasSize(){const rect=document.getElementById('game-wrapper').getBoundingClientRect();canvas.width=rect.width;canvas.height=rect.height;}
        
        function resetGame(){
            keys.left=false;keys.right=false;scoreDisplay.style.display='block';player={x:canvas.width/2-25,y:canvas.height-95,width:50,height:85,dx:0,dy:0,direction:'right',animationState:'idle',frameCount:0,animationFrame:0};platforms=[];cameraY=0;score=0;baseScore=0;bonusScore=0;finalGameScore=0;highestY=player.y;scoreDisplay.innerText=0;platforms.push({x:0,y:canvas.height-40,width:canvas.width,height:40,type:'static'});for(let i=1;i<15;i++)generatePlatform(canvas.height-i*100);
            stars = []; for(let i=0; i<150; i++){ const alpha = Math.random()*0.7+0.3; stars.push({ x:Math.random()*canvas.width, y:Math.random()*canvas.height*2, radius:Math.random()*1.5+0.5, alpha:alpha, baseAlpha:alpha, twinkleSpeed:Math.random()*0.005+0.001 }); }
            moon = { x: canvas.width * 0.8, y: 150, radius: 40 };
            gameState='playing';
            backgroundState = 0; currentBgTop = backgrounds[0].top; currentBgBottom = backgrounds[0].bottom;
            comboCount = 0; comboDisplay.style.opacity = 0; clearTimeout(comboTimeout); lastPlatform = null; particles = [];
            backgroundElements = [];
            lastMilestoneScore = 0;
            
            const allBackgroundSpriteNames = backgroundSpriteData.sprites.map(s => s.name);
            shuffleArray(allBackgroundSpriteNames);
            availableBackgroundSprites = allBackgroundSpriteNames;
        }
        
        function generatePlatform(yPos){const width=Math.random()*80+80;const x=Math.random()*(canvas.width-width);let type='static',dx=0;const rand=Math.random();if(score>200&&rand<0.20)type='crumbling';else if(score>50&&rand<0.25){type='moving';dx=(Math.random()>0.5?1:-1)*(Math.random()*1.5+1);}platforms.push({x,y:yPos,width,height:20,type,dx,state:'intact',alpha:1});}
        
        function update(deltaTime){
            if(gameState!=='playing'||!player)return;
            const speed = Math.min(9 + score * 0.007, 16); 
            player.dx=0;
            if(keys.left){ player.dx=-speed; player.direction = 'left'; }
            if(keys.right){ player.dx=speed; player.direction = 'right'; }
            const currentJumpForce = JUMP_FORCE;
            player.dy += GRAVITY * deltaTime; player.x += player.dx * deltaTime; player.y += player.dy * deltaTime;
            if(player.dy > 0){platforms.forEach(p => {if(player.x < p.x + p.width && player.x + player.width > p.x && player.y + player.height > p.y && player.y + player.height < p.y + p.height + 20) {
                player.y = p.y - player.height; player.dy = currentJumpForce; 
                if(isAudioReady) jumpSound.triggerAttackRelease("C5","0.05"); 
                if(p.type === 'crumbling' && p.state === 'intact'){p.state = 'shaking'; if(isAudioReady) crumbleSound.triggerAttackRelease("0.1");} 
                if(p.type === 'moving') player.x += p.dx * deltaTime;
                handleCombo(p);
            }}); }
            if(player.x < -player.width) player.x = canvas.width; if(player.x > canvas.width) player.x = -player.width;
            if(player.y < cameraY + canvas.height / 2.5) cameraY = player.y - canvas.height / 2.5;
            
            if(player.y < highestY){
                highestY = player.y; 
                baseScore = Math.floor((canvas.height - 80 - highestY) / 10);
            }
            score = baseScore + bonusScore;
            scoreDisplay.innerText = score;
            
            if (score > lastMilestoneScore + 500) {
                lastMilestoneScore += 500;
                
                if (availableBackgroundSprites.length === 0) {
                    const allBackgroundSpriteNames = backgroundSpriteData.sprites.map(s => s.name);
                    shuffleArray(allBackgroundSpriteNames);
                    availableBackgroundSprites = allBackgroundSpriteNames;
                }

                const spriteName = availableBackgroundSprites.pop();
                const spriteInfo = backgroundSpriteData.sprites.find(s => s.name === spriteName);
                
                if(spriteInfo){
                     backgroundElements.push({
                        spriteName: spriteInfo.name,
                        x: Math.random() * (canvas.width - (spriteInfo.w / 1.5)),
                        y: player.y - canvas.height - (Math.random() * 200),
                        width: spriteInfo.w / 1.5,
                        height: spriteInfo.h / 1.5
                    });
                }
            }

            platforms.forEach(p => {if(p.type === 'moving'){p.x += p.dx * deltaTime; if(p.x < 0 || p.x + p.width > canvas.width) p.dx *= -1;} if(p.state === 'shaking') p.alpha = Math.max(0, p.alpha - 0.02 * deltaTime);});
            if(platforms.length > 0 && platforms[platforms.length - 1].y > cameraY - 100){generatePlatform(platforms[platforms.length - 1].y - (Math.random() * 60 + 80));}
            platforms = platforms.filter(p => p.y < cameraY + canvas.height + 50 && p.alpha > 0);
            backgroundElements = backgroundElements.filter(el => el.y < cameraY + canvas.height + 50);

            player.frameCount++; 
            const currentAnimData = animations[player.animationState];
            if(player.frameCount % currentAnimData.speed === 0) { player.animationFrame = (player.animationFrame + 1) % currentAnimData.frames.length; }
            if(player.dy < 0) player.animationState = 'jumping'; else if(keys.left || keys.right) player.animationState = 'running'; else player.animationState = 'idle';
            if(player.y > cameraY + canvas.height) endGame();

            let targetState = 0;
            if (score > 2500) targetState = 3; else if (score > 1500) targetState = 2; else if (score > 500) targetState = 1;
            if (backgroundState !== targetState) {
                backgroundState = targetState;
            }

            const lerp = (start, end, amt) => (1 - amt) * start + amt * end;
            const targetBg = backgrounds[backgroundState];
            currentBgTop.r = lerp(currentBgTop.r, targetBg.top.r, 0.01 * deltaTime); currentBgTop.g = lerp(currentBgTop.g, targetBg.top.g, 0.01 * deltaTime); currentBgTop.b = lerp(currentBgTop.b, targetBg.top.b, 0.01 * deltaTime);
            currentBgBottom.r = lerp(currentBgBottom.r, targetBg.bottom.r, 0.01 * deltaTime); currentBgBottom.g = lerp(currentBgBottom.g, targetBg.bottom.g, 0.01 * deltaTime); currentBgBottom.b = lerp(currentBgBottom.b, targetBg.bottom.b, 0.01 * deltaTime);

            stars.forEach(s => { s.alpha = s.baseAlpha + Math.sin(Date.now() * s.twinkleSpeed) * (s.baseAlpha / 2); });
            particles.forEach((p, i) => { p.x += p.dx * deltaTime; p.y += p.dy * deltaTime; p.life -= deltaTime; if(p.life <= 0) particles.splice(i, 1); });
        }
        
        function draw(){
            const rgbToString = (rgb) => `rgb(${Math.round(rgb.r)}, ${Math.round(rgb.g)}, ${Math.round(rgb.b)})`;
            const bgGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGrad.addColorStop(0, rgbToString(currentBgTop)); bgGrad.addColorStop(1, rgbToString(currentBgBottom));
            ctx.fillStyle = bgGrad; ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(0, -cameraY * 0.8);
            if (backgroundState === 0 && moon) {
                ctx.fillStyle = 'rgba(240, 240, 255, 0.8)'; ctx.shadowColor = 'white'; ctx.shadowBlur = 20;
                ctx.beginPath(); ctx.arc(moon.x, moon.y, moon.radius, 0, Math.PI * 2); ctx.fill();
                ctx.shadowBlur = 0;
            }
            stars.forEach(s => {
                let starColor = `rgba(255, 255, 255, ${s.alpha})`;
                if (backgroundState === 2) starColor = `rgba(200, 180, 255, ${s.alpha})`;
                else if (backgroundState === 3) starColor = `rgba(255, 220, 150, ${s.alpha})`;
                ctx.fillStyle = starColor;
                ctx.beginPath(); ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2); ctx.fill();
            });
            ctx.restore();
            
            ctx.save();
            ctx.translate(0, -cameraY * 0.5);
            if (isBackgroundSheetLoaded) {
                backgroundElements.forEach(el => {
                    const sprite = backgroundSpriteData.sprites.find(s => s.name === el.spriteName);
                    if (sprite) {
                        ctx.drawImage(backgroundSheet, sprite.x, sprite.y, sprite.w, sprite.h, el.x, el.y, el.width, el.height);
                    }
                });
            }
            ctx.restore();


            if(gameState!=='playing'||!player)return;
            ctx.save();ctx.translate(0,-cameraY);
            platforms.forEach(p=>{ctx.globalAlpha=p.alpha;const grad=ctx.createLinearGradient(p.x,p.y,p.x,p.y+p.height);if(p.type==='moving'){grad.addColorStop(0,'#ff8c42');grad.addColorStop(1,'#ff5e57');}else if(p.state==='shaking'){grad.addColorStop(0,'#b0a090');grad.addColorStop(1,'#8a7a6a');}else{grad.addColorStop(0,'#6c5b7b');grad.addColorStop(1,'#355c7d');}ctx.fillStyle=grad;ctx.fillRect(p.x+(p.state==='shaking'?(Math.random()-0.5)*4:0),p.y,p.width,p.height);ctx.globalAlpha=1;});
            
            ctx.fillStyle = 'rgba(250, 204, 21, 0.8)';
            particles.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, p.size * (p.life / 60), 0, Math.PI * 2); ctx.fill(); });

            drawPlayer();
            ctx.restore();
        }
        
        function gameLoop(currentTime){
            if(!lastTime) lastTime = currentTime;
            const deltaTime = (currentTime - lastTime) / (1000 / 60);
            lastTime = currentTime;
            update(deltaTime);
            draw();
            requestAnimationFrame(gameLoop);
        }

        function drawPlayer() {
            if (!player || !isSpriteSheetLoaded) return;
            const currentAnim = animations[player.animationState];
            let frameIndex = player.animationFrame;
            if (player.animationState === 'jumping') { frameIndex = player.dy < 0 ? 0 : 1; }
            const spriteName = currentAnim.frames[frameIndex];
            const sprite = spriteMap[spriteName];
            if (!sprite) return;
            ctx.save();
            const cX = player.x + player.width / 2; const cY = player.y + player.height / 2;
            ctx.translate(cX, cY);
            if (player.direction === 'left') { ctx.scale(-1, 1); }
            
            ctx.drawImage(spriteSheet, sprite.x, sprite.y, sprite.w, sprite.h, -player.width / 2, -player.height / 2, player.width, player.height);
            
            // 캐릭터 틴트 효과
            if (backgroundState > 1) { // 2: 제4세계, 3: 천상계에서만 적용
                let tintColor = '';
                if (backgroundState === 2) tintColor = 'rgba(162, 82, 255, 0.15)'; // 제4세계
                if (backgroundState === 3) tintColor = 'rgba(250, 204, 21, 0.15)';   // 천상계

                if (tintColor) {
                    ctx.globalCompositeOperation = 'source-atop';
                    ctx.fillStyle = tintColor;
                    ctx.fillRect(-player.width / 2, -player.height / 2, player.width, player.height);
                }
            }

            ctx.restore();
        }

        // --- 콤보 & 파티클 함수 ---
        function handleCombo(platform) {
            if (platform === lastPlatform) return; 
            lastPlatform = platform;
            comboCount++;
            clearTimeout(comboTimeout);
            if (comboCount >= 2) {
                const comboBonus = comboCount * 5;
                bonusScore += comboBonus;
                comboDisplay.innerText = `${comboCount} COMBO`;
                comboDisplay.style.opacity = 1;
                anime.remove(comboDisplay);
                anime({ targets: comboDisplay, scale: [1.5, 1], translateY: [-20, 0], duration: 400, easing: 'easeOutElastic(1, .8)' });
                createParticles();
            }
            comboTimeout = setTimeout(() => {
                anime({ targets: comboDisplay, opacity: 0, duration: 500, easing: 'easeOutExpo', complete: () => { comboCount = 0; lastPlatform = null; } });
            }, 1500);
        }
        function createParticles() {
            const pX = player.x + player.width / 2;
            const pY = player.y + player.height / 2;
            for (let i = 0; i < 10; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                particles.push({
                    x: pX, y: pY,
                    dx: Math.cos(angle) * speed,
                    dy: Math.sin(angle) * speed,
                    size: Math.random() * 3 + 2,
                    life: 60
                });
            }
        }

        // --- State Transition ---
        function startGame() { 
            initAudio(); 
            startScreen.classList.add('hidden'); 
            touchLeft.classList.add('visible');
            touchRight.classList.add('visible');
            setTimeout(resetGame, 500); 
        }
        function endGame() {
            gameState = 'gameOver'; finalGameScore = score;
            if(isAudioReady) gameOverSound.triggerAttackRelease("C2", "0.5");
            scoreDisplay.style.display = 'none'; 
            gameOverScreen.classList.remove('hidden');
            touchLeft.classList.remove('visible');
            touchRight.classList.remove('visible');
            clearTimeout(comboTimeout); comboCount = 0; comboDisplay.style.opacity = 0; lastPlatform = null;
            
            const scoreObj = { value: 0 };
            anime({ targets: scoreObj, value: finalGameScore, round: 1, duration: 1200, easing: 'easeOutCubic', update: () => { finalScoreEl.innerText = scoreObj.value.toLocaleString(); } });
            
            const tl = anime.timeline({ easing: 'easeOutExpo', duration: 750 });
            tl.add({ targets: ['#finalScoreLabel', '#finalScore'], translateY: [20, 0], opacity: [0, 1], delay: anime.stagger(100) })
              .add({ targets: ['.content-wrapper', '.button-group'], translateY: [20, 0], opacity: [0, 1], delay: anime.stagger(100) }, '-=500');

            loadRankingAndGuestbook();
        }
        function restartGame() {
            gameOverScreen.classList.add('hidden');
            document.querySelectorAll('#gameOverScreen .content-wrapper, #gameOverScreen .button-group, #finalScoreLabel, #finalScore').forEach(el => { el.style.opacity = 0; });
            setTimeout(() => {
                guestbookLimit = 3; 
                startGame();
            }, 500);
        }
        
        // --- Supabase Functions ---
        async function loadRankingAndGuestbook() {
            if (!supabase) {
                const errorMsg = `<p style="color: var(--error-color);">서버에 연결할 수 없습니다.</p>`;
                rankingList.innerHTML = errorMsg;
                guestbookEntries.innerHTML = errorMsg;
                return;
            }
            fetchRankings();
            fetchGuestbookEntries();
        }

        async function fetchRankings() {
            try {
                const { data, error } = await supabase.from('guestbook').select('name, score').order('score', { ascending: false }).limit(5);
                if (error) throw error;
                rankingList.innerHTML = '';
                if (data.length === 0) {
                    rankingList.innerHTML = '<p>아직 등록된 기록이 없습니다.</p>';
                } else {
                    data.forEach((entry, index) => {
                        const li = document.createElement('li');
                        li.innerHTML = `<span class="rank-name">${index + 1}. ${escapeHtml(entry.name)}</span> <span class="rank-score">${entry.score.toLocaleString()}</span>`;
                        rankingList.appendChild(li);
                    });
                }
            } catch (error) { console.error('랭킹 로딩 오류:', error); rankingList.innerHTML = `<p style="color: var(--error-color);">랭킹 로딩 실패: ${error.message}</p>`; }
        }

        async function fetchGuestbookEntries() {
            try {
                const { data, error, count } = await supabase.from('guestbook').select('*', { count: 'exact' }).order('created_at', { ascending: false }).limit(guestbookLimit);
                if (error) throw error;
                
                guestbookEntries.innerHTML = '';
                if (data.length === 0) {
                    guestbookEntries.innerHTML = '<p>첫 방명록을 남겨주세요.</p>';
                } else {
                    data.forEach(entry => {
                        const div = document.createElement('div');
                        div.className = 'guestbook-entry';
                        div.innerHTML = `<p><strong>${escapeHtml(entry.name)}:</strong> ${escapeHtml(entry.message)}<span class="score">(${entry.score.toLocaleString()}점)</span></p>`;
                        guestbookEntries.appendChild(div);
                    });
                }
                if (count > guestbookLimit) {
                    moreGuestbookBtn.classList.remove('hidden');
                } else {
                    moreGuestbookBtn.classList.add('hidden');
                }
            } catch (error) { console.error('방명록 로딩 오류:', error); guestbookEntries.innerHTML = `<p style="color: var(--error-color);">방명록 로딩 실패: ${error.message}</p>`; }
        }

        async function handleGuestbookSubmit(e) {
            e.preventDefault();
            if (!supabase) return;
            const lastPostTime = localStorage.getItem('lastPostTime');
            if (lastPostTime && Date.now() - lastPostTime < 30000) {
                showError(`${Math.ceil((30000 - (Date.now() - lastPostTime)) / 1000)}초 후 등록 가능합니다.`);
                return;
            }
            const name = guestbookName.value.trim();
            const message = guestbookMessage.value.trim();
            if (!name || !message) { showError('이름과 메시지를 입력해주세요.'); return; }
            guestbookSubmit.disabled = true; guestbookSubmit.textContent = '...';
            try {
                const { error } = await supabase.from('guestbook').insert([{ name, message, score: finalGameScore }]);
                if (error) throw error;
                guestbookForm.reset();
                localStorage.setItem('lastPostTime', Date.now());
                guestbookLimit = 3;
                loadRankingAndGuestbook();
            } catch (error) { console.error('방명록 등록 오류:', error); showError(`등록 실패: ${error.message}`); } 
            finally { guestbookSubmit.disabled = false; guestbookSubmit.textContent = '등록'; }
        }
        
        function showError(message) { guestbookError.textContent = message; setTimeout(() => { guestbookError.textContent = ''; }, 3000); }
        function escapeHtml(str) { return str.replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m])); }

        // --- Event Listeners & Main Setup ---
        function setupListeners() {
            window.addEventListener('resize', setCanvasSize, { passive: true });
            startScreen.addEventListener('click', startGame);
            restartButton.addEventListener('click', restartGame);
            
            if (supabase) {
                guestbookForm.addEventListener('submit', handleGuestbookSubmit);
                moreGuestbookBtn.addEventListener('click', () => {
                    guestbookLimit += 5;
                    fetchGuestbookEntries();
                });
            }
            const handleMoveStart=(x)=>{if(gameState!=='playing')return;const mid=canvas.getBoundingClientRect().left+canvas.width/2;keys.left=x<mid;keys.right=x>=mid;};
            const handleMoveEnd=()=>{if(gameState==='playing'){keys.left=false;keys.right=false;}};
            canvas.addEventListener('mousedown', e => handleMoveStart(e.clientX));
            canvas.addEventListener('mouseup', handleMoveEnd);
            canvas.addEventListener('mouseleave', handleMoveEnd);
            canvas.addEventListener('mousemove', e => { if (e.buttons === 1) handleMoveStart(e.clientX); });
            canvas.addEventListener('touchstart',e=>{e.preventDefault();handleMoveStart(e.touches[0].clientX);},{passive:false});
            canvas.addEventListener('touchmove',e=>{e.preventDefault();handleMoveStart(e.touches[0].clientX);},{passive:false});
            canvas.addEventListener('touchend',e=>{e.preventDefault();handleMoveEnd();},{passive:false});
            document.addEventListener('keydown',e=>{if(gameState!=='playing')return;if(e.code==='ArrowLeft'||e.code==='KeyA')keys.left=true;if(e.code==='ArrowRight'||e.code==='KeyD')keys.right=true;});
            document.addEventListener('keyup',e=>{if(e.code==='ArrowLeft'||e.code==='KeyA')keys.left=false;if(e.code==='ArrowRight'||e.code==='KeyD')keys.right=false;});
        }

        function init() {
            setCanvasSize();
            setupListeners();
            spriteSheet.src = 'https://fzfnjtlzovbpbglvkroh.supabase.co/storage/v1/object/public/images/jump.webp';
            spriteSheet.onload = () => { isSpriteSheetLoaded = true; };
            backgroundSheet.src = 'https://fzfnjtlzovbpbglvkroh.supabase.co/storage/v1/object/public/images/background1.webp';
            backgroundSheet.onload = () => { isBackgroundSheetLoaded = true; };

            const mainTitle = document.getElementById('main-title');
            mainTitle.innerHTML = mainTitle.textContent.replace(/\S/g, "<span class='title-char'>$&</span>");
            anime({ targets: '#intro-character', translateY: [-20, 0], opacity: [0, 1], easing: 'easeOutExpo', duration: 1000 });
            anime({ targets: '.title-char', translateY: ["1.1em", 0], translateZ: 0, duration: 750, delay: (el, i) => 50 * i, easing: 'easeOutExpo' });
            requestAnimationFrame(gameLoop);
        }

        init();
    });
</script>

</body>
</html>

