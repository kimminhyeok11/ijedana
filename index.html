<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>시련의 탑</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700;900&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --gold-color: #D4AF37;
            --dark-bg: #1a1a2e;
            --panel-bg: rgba(12, 12, 22, 0.85);
            --border-color: #4a4a68;
            --border-gold-gradient: linear-gradient(to bottom, #E6C66E, #A38A00);
        }
        /* --- 기본 설정 및 애니메이션 --- */
        body { font-family: 'Noto Sans KR', sans-serif; background-color: var(--dark-bg); color: #e0e0e0; overflow: hidden; -webkit-tap-highlight-color: transparent; }
        .font-cinzel { font-family: 'Cinzel', serif; }
        .hidden { display: none !important; }
        .fade-in { animation: fade-in 0.5s ease-out forwards; }
        @keyframes fade-in { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slow-pan { 0%, 100% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } }
        @keyframes title-glow { 0%, 100% { text-shadow: 0 0 10px #fff, 0 0 20px var(--gold-color), 0 0 30px var(--gold-color); } 50% { text-shadow: 0 0 20px #fff, 0 0 40px var(--gold-color), 0 0 50px var(--gold-color); } }
        @keyframes subtitle-fade { 0%, 100% { opacity: 0.7; } 50% { opacity: 1; } }
        @keyframes take-damage-anim { 0%,100%{filter:brightness(1)} 50%{filter:brightness(3) contrast(2)} }
        .take-damage { animation: take-damage-anim 0.3s; }
        @keyframes attack-forward { 0%,100%{transform:translate(0,0)} 50%{transform:translate(20px,-10px) scale(1.1)} }
        .player.attack { animation: attack-forward 0.4s; }
        .enemy.attack { animation: attack-forward 0.4s; animation-name: attack-backward; }
        @keyframes attack-backward { 0%,100%{transform:translate(0,0)} 50%{transform:translate(-20px,-10px) scale(1.1)} }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes notification-ping { 0% { transform: scale(1); opacity: 1; } 75%, 100% { transform: scale(2); opacity: 0; } }
        
        .notification-dot { display: none; }
        .has-points .notification-dot { 
            display: block;
            position: absolute; top: -2px; right: -2px; width: 12px; height: 12px; background-color: #ef4444; border-radius: 50%; border: 2px solid var(--dark-bg); 
        }
        .has-points .notification-dot::after { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 50%; background-color: #ef4444; animation: notification-ping 1s cubic-bezier(0, 0, 0.2, 1) infinite; }

        /* --- 화면 구성 --- */
        .game-screen, .modal-overlay { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.5s; }
        .overlay { background-color: rgba(0,0,0,0.7); backdrop-filter: blur(10px); }
        #title-screen { text-align: center; background: linear-gradient(rgba(0,0,0,0.6), rgba(0,0,0,0.6)), url('https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/file_00000000497c61fa963025bb3510d7bb_copy_1152x768.webp'); background-size: cover; background-repeat: no-repeat; animation: slow-pan 30s ease-in-out infinite; }
        #title-screen h1 { animation: title-glow 3s ease-in-out infinite; }
        #title-screen h2 { text-shadow: 0 0 5px #fff; animation: subtitle-fade 4s ease-in-out infinite; }
        #loading-screen .spinner { width: 60px; height: 60px; border: 5px solid var(--border-color); border-top-color: var(--gold-color); border-radius: 50%; animation: spin 1s linear infinite; }

        .class-card, .skill-card { background: var(--panel-bg); border: 2px solid var(--border-color); transition: all 0.3s; cursor: pointer; position: relative; overflow: hidden; }
        .class-card:hover, .skill-card:hover { transform: scale(1.05); border-color: var(--gold-color); box-shadow: 0 0 20px var(--gold-color); }
        .skill-card.selected { border-color: var(--gold-color); box-shadow: 0 0 20px var(--gold-color); transform: scale(1.05); }
        .class-card { width: 200px; height: 300px; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .class-card svg { width: 80px; height: 80px; margin-bottom: 1rem; color: var(--gold-color); }
        .class-card h3 { font-family: 'Cinzel', serif; font-size: 1.5rem; color: var(--gold-color); }
        .class-card p { font-size: 0.8rem; color: #ccc; text-align: center; padding: 0 1rem; }
        #starter-skills-container, #passive-skills-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; width: 100%; max-width: 800px; margin-bottom: 2rem; }
        .skill-card { padding: 1rem; text-align: center; }
        .skill-card h4 { font-size: 0.9rem; font-weight: bold; }
        .skill-card p { font-size: 0.75rem; color: #bbb; }

        .game-button { font-family: 'Cinzel', serif; background: linear-gradient(145deg, #3a3a5e, #2a2a4e); border: 2px solid var(--border-color); padding: 0.75rem 2rem; font-size: 1.25rem; color: var(--gold-color); text-shadow: 0 0 10px var(--gold-color); transition: all 0.3s; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
        .game-button:hover:not(:disabled) { transform: scale(1.05); border-color: var(--gold-color); box-shadow: 0 0 20px var(--gold-color); }
        .game-button:disabled { opacity: 0.5; cursor: not-allowed; }

        .battle-scene { background-size: cover; background-position: center; width: 100vw; height: 100vh; position: relative; transition: background-image 0.5s ease-in-out; }
        .character { position: absolute; bottom: 15%; width: 28%; max-width: 300px; transition: transform 0.2s; display: flex; justify-content: center; align-items: flex-end; }
        .player { left: 5%; }
        .enemy { right: 10%; }
        .character img { width: 100%; height: auto; object-fit: contain; filter: drop-shadow(0 5px 20px rgba(0,0,0,0.8)); }
        #player-sprite {
            background-repeat: no-repeat;
            image-rendering: pixelated;
            filter: drop-shadow(0 5px 20px rgba(0,0,0,0.8));
            transform-origin: bottom center;
        }

        .ui-panel { position: absolute; width: 25%; max-width: 320px; background: var(--panel-bg); border: 2px solid; border-image-source: var(--border-gold-gradient); border-image-slice: 1; padding: 0.75rem; backdrop-filter: blur(5px); }
        .player-ui { top: 2%; left: 1%; }
        .enemy-ui { top: 2%; right: 1%; }
        .bar-container { background-color: #1f1f3d; border-radius: 4px; overflow: hidden; border: 1px solid var(--border-color); padding: 1px; }
        .bar { transition: width 0.5s; border-radius: 2px; }
        .hp-bar { height: 14px; background: linear-gradient(to right, #4ade80, #16a34a); }
        .mp-bar { height: 10px; background: linear-gradient(to right, #60a5fa, #2563eb); }
        .xp-bar { height: 6px; background: linear-gradient(to right, #8b5cf6, #6d28d9); }
        .hp-text, .mp-text { font-size: 0.8rem; font-family: monospace; }
        
        .buff-container { display: flex; gap: 4px; margin-top: 6px; min-height: 28px; flex-wrap: wrap; }
        .buff-icon { position: relative; width: 24px; height: 24px; border-radius: 4px; overflow: hidden; border: 1px solid var(--gold-color); }
        .buff-icon .duration { position: absolute; bottom: 0; right: 0; font-size: 10px; font-weight: bold; background-color: rgba(0,0,0,0.7); color: white; padding: 0 2px; border-radius: 2px 0 0 0; }

        .controls { position: absolute; bottom: 1%; left: 50%; transform: translateX(-50%); width: 95%; max-width: 820px; display: flex; align-items: flex-end; justify-content: center; gap: 0.5rem; }
        .menu-btn { position: relative; background: linear-gradient(145deg, #2a2a4e, #1a1a2e); border: 1px solid var(--border-color); width: 48px; height: 48px; display: flex; align-items: center; justify-content: center; transition: all 0.2s; box-shadow: 0 2px 5px rgba(0,0,0,0.5); border-radius: 0.75rem; }
        .menu-btn:hover { border-color: var(--gold-color); transform: translateY(-2px); }
        .menu-btn svg { width: 24px; height: 24px; color: var(--gold-color); }
        
        .player-ui .menu-buttons { display: flex; gap: 0.25rem; }
        .player-ui .menu-btn { width: 36px; height: 36px; border-radius: 0.5rem; }
        .player-ui .menu-btn svg { width: 20px; height: 20px; }

        .skills-container { display: flex; align-items: center; gap: 0.5rem; background: var(--panel-bg); border-top: 2px solid; border-image-source: var(--border-gold-gradient); border-image-slice: 1; padding: 0.5rem; border-radius: 1rem 1rem 0 0; flex-wrap: wrap; justify-content: center; }
        .skill-btn { background: #1f1f3d; border: 1px solid var(--border-color); transition: all 0.2s; width: 64px; height: 64px; display: flex; flex-direction: column; align-items: center; justify-content: center; border-radius: 0.75rem; overflow: hidden; padding: 2px; }
        .skill-btn:hover:not(:disabled) { border-color: var(--gold-color); transform: scale(1.1); box-shadow: 0 0 10px rgba(255, 215, 0, 0.3); }
        .skill-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .skill-btn .icon-wrapper { width: 36px; height: 36px; overflow: hidden; border-radius: 0.375rem; }
        .skill-btn .skill-label { font-size: 0.6rem; line-height: 0.7rem; margin-top: 2px; text-align: center; }
        
        .log-panel { position: absolute; top: 2%; left: 50%; transform: translateX(-50%); width: 40%; max-width: 500px; height: 30px; background: rgba(12, 12, 22, 0.7); border: 1px solid var(--border-color); overflow: hidden; font-size: 0.8rem; border-radius: 15px; transition: height 0.3s; }
        .log-panel:hover { height: 120px; }
        #log-messages-container { display: flex; flex-direction: column; justify-content: flex-end; height: 100%; }
        
        .modal-content { background: var(--panel-bg); border: 2px solid; border-image-source: var(--border-gold-gradient); border-image-slice: 1; padding: 1.5rem; width: 90%; max-width: 800px; max-height: 85vh; overflow-y: auto; }
        .stat-row { display: grid; grid-template-columns: 1fr auto; gap: 0.5rem; align-items: center; }
        .stat-value { text-align: center; }
        .stat-btn { background: var(--gold-color); color: black; border-radius: 50%; width: 24px; height: 24px; font-weight: bold; }
        
        #skill-modal-layout { display: grid; grid-template-columns: 1fr; gap: 1rem; }
        @media (min-width: 768px) { #skill-modal-layout { grid-template-columns: 300px 1fr; } }
        #skill-list-panel { background: #1f1f3d; border-radius: 0.5rem; border: 1px solid var(--border-color); overflow-y: auto; max-height: 60vh; }
        .skill-list-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem; border-bottom: 1px solid var(--border-color); cursor: pointer; transition: background-color 0.2s; }
        .skill-list-item:hover { background-color: rgba(255,255,255,0.1); }
        .skill-list-item.selected { background-color: var(--gold-color); color: black; }
        .skill-list-item .icon-container { width: 40px; height: 40px; flex-shrink: 0; }
        #skill-details-panel { background: #1f1f3d; padding: 1rem; border-radius: 0.5rem; border: 1px solid var(--border-color); }

        .tooltip { position: absolute; bottom: 115%; left: 50%; transform: translateX(-50%); width: 250px; background: black; border: 1px solid var(--gold-color); padding: 0.75rem; border-radius: 0.5rem; z-index: 10; pointer-events: none; opacity: 0; transition: opacity 0.2s, visibility 0.2s; visibility: hidden; }
        .skill-node:hover .tooltip, .skill-btn:hover .tooltip, .tooltip.show { opacity: 1; visibility: visible; }
        
        .skill-sprite-icon {
            width: 100%; height: 100%;
            background-repeat: no-repeat;
            image-rendering: pixelated;
        }

        #vfx-container { position: absolute; inset: 0; pointer-events: none; overflow: hidden; }
        .vfx { position: absolute; }
        .vfx-slash { width: 150px; height: 150px; background: radial-gradient(circle, rgba(255,255,255,0) 0%, rgba(255,255,255,0.8) 40%, rgba(255,255,255,0) 70%); border-radius: 50%; animation: vfx-fade-scale 0.3s forwards; }
        .vfx-fireball { width: 80px; height: 80px; background: radial-gradient(circle, #ffae42, #ff7900, transparent 70%); border-radius: 50%; animation: vfx-travel 0.5s linear forwards; box-shadow: 0 0 20px #ffae42; }
        .vfx-ice_shard { width: 20px; height: 60px; background: linear-gradient(to bottom, #a0e9ff, #d0f4ff); border-radius: 50% 50% 0 0; animation: vfx-travel 0.4s linear forwards; filter: drop-shadow(0 0 10px #a0e9ff); clip-path: polygon(50% 0%, 0% 100%, 100% 100%); }
        .vfx-lightning { width: 10px; height: 100%; background: #f0f8ff; box-shadow: 0 0 20px #add8e6; animation: vfx-fade-fast 0.3s forwards; clip-path: polygon(50% 0, 60% 20%, 45% 40%, 55% 60%, 40% 80%, 50% 100%, 60% 80%, 45% 60%, 55% 40%, 40% 20%); }
        .vfx-shadow_strike { width: 100px; height: 100px; background: radial-gradient(circle, transparent 50%, #483d8b 70%); border-radius: 50%; animation: vfx-fade-scale 0.4s forwards; }
        .vfx-holy { width: 200px; height: 200px; background: radial-gradient(circle, rgba(255,215,0,0.8) 0%, transparent 70%); border-radius: 50%; animation: vfx-fade-fast 0.5s forwards; }
        .vfx-dragon_breath { width: 100%; height: 200px; background: linear-gradient(to left, transparent, rgba(255, 69, 0, 0.8), transparent); animation: vfx-fade-fast 0.6s forwards; }
        .vfx-heal-particle { position: absolute; width: 8px; height: 8px; background-color: #4ade80; border-radius: 50%; box-shadow: 0 0 10px #4ade80; animation: vfx-heal-anim 1s ease-out forwards; }
        .vfx-damage-text { position: absolute; font-family: 'Cinzel', serif; font-size: 2rem; font-weight: bold; text-shadow: 1px 1px 2px black; animation: vfx-damage-float 1.5s ease-out forwards; }
        .critical { font-size: 2.5rem !important; color: var(--gold-color) !important; font-weight: 900; }
        @keyframes vfx-damage-float { from { transform: translateY(0); opacity: 1; } to { transform: translateY(-80px); opacity: 0; } }
        @keyframes vfx-fade-scale { from{transform:scale(0); opacity:1;} to{transform:scale(1.5); opacity:0;} }
        @keyframes vfx-fade-fast { from{opacity:1;} to{opacity:0;} }
        @keyframes vfx-travel { from{transform:translateX(0) scale(0.5)} to{transform:translateX(var(--travel-dist, -300px)) scale(1)} }
        @keyframes vfx-heal-anim { from{transform:translateY(0) scale(1); opacity:1;} to{transform:translateY(-100px) scale(0); opacity:0;} }

        @media (max-width: 768px) {
            #title-screen h1 { font-size: 3rem; }
            #title-screen h2 { font-size: 1.5rem; }
            #class-selection-screen .flex { flex-direction: column; gap: 1rem; }
            #class-selection-screen .class-card { width: 220px; height: 200px; }
            
            #battle-scene { background-position: center 25%; }
            .character { bottom: 25%; }
            .ui-panel { width: 45%; font-size: 0.8rem; }
            .ui-panel h2 { font-size: 1rem; }
            .hp-bar { height: 10px; } .mp-bar { height: 8px; } .xp-bar { height: 5px; }
            .hp-text, .mp-text { font-size: 0.7rem; }

            .controls { flex-direction: column; align-items: center; }
            .skills-container { order: 1; }
            .skill-btn { width: 56px; height: 56px; }
            .skill-btn .icon-wrapper { width: 32px; height: 32px; }

            .log-panel { bottom: 150px; top: auto; height: 80px; width: 90%; }
            .log-panel:hover { height: 80px; }
        }
    </style>
</head>
<body>
    <audio id="bgm" loop src="https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/cave-141845.mp3"></audio>
    <div id="game-container">
        <div id="loading-screen" class="game-screen">
            <div class="spinner"></div>
            <p class="mt-4 text-lg font-cinzel text-gray-400">Now Loading...</p>
        </div>
        <div id="title-screen" class="game-screen hidden">
            <h1 class="text-8xl font-cinzel text-white mb-4">TOWER OF TRIALS</h1>
            <h2 class="text-4xl font-cinzel text-gray-300 mb-12">시련의 탑</h2>
            <button id="start-game-btn" class="game-button">게임 시작</button>
        </div>
        <div id="class-selection-screen" class="game-screen overlay hidden">
            <h2 class="text-5xl font-cinzel text-yellow-300 mb-10">최초의 길을 선택하십시오</h2>
            <div class="flex flex-wrap justify-center gap-8">
                <div data-class="warrior" class="class-card rounded-lg">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L1 9l4 12h14l4-12L12 2zm0 4.69L15.53 9h-7.06L12 6.69zM6.47 19L5 13.58l5.5-2.2V19H6.47zm6.5-7.62L18 13.58 16.53 19H13v-7.62z"></path></svg>
                    <h3>전사</h3>
                    <p>강인한 체력과 힘으로 적을 압도합니다.</p>
                </div>
                <div data-class="mage" class="class-card rounded-lg">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2.25a.75.75 0 01.75.75v3a.75.75 0 01-1.5 0v-3a.75.75 0 01.75-.75zM12 18a.75.75 0 01.75.75v3a.75.75 0 01-1.5 0v-3A.75.75 0 0112 18zM5.25 12a.75.75 0 01-.75-.75h-3a.75.75 0 010-1.5h3a.75.75 0 01.75.75zM21 12a.75.75 0 01-.75-.75h-3a.75.75 0 010-1.5h3a.75.75 0 01.75.75zM7.34 7.34a.75.75 0 011.06 0l2.12 2.12a.75.75 0 01-1.06 1.06L7.34 8.4A.75.75 0 017.34 7.34zM14.47 14.47a.75.75 0 011.06 0l2.12 2.12a.75.75 0 01-1.06 1.06l-2.12-2.12a.75.75 0 010-1.06zM16.59 7.34a.75.75 0 010 1.06L14.47 10.52a.75.75 0 01-1.06-1.06l2.12-2.12a.75.75 0 011.06 0zM8.4 14.47a.75.75 0 010 1.06L6.28 17.65a.75.75 0 01-1.06-1.06l2.12-2.12a.75.75 0 011.06 0z"></path></svg>
                    <h3>마법사</h3>
                    <p>원소의 힘을 빌려 강력한 마법을 사용합니다.</p>
                </div>
                <div data-class="rogue" class="class-card rounded-lg">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M14.25 2.25a.75.75 0 01.75.75v18a.75.75 0 01-1.5 0V3a.75.75 0 01.75-.75zm-4.5 0a.75.75 0 01.75.75v18a.75.75 0 01-1.5 0V3a.75.75 0 01.75-.75zm-3.75 9a.75.75 0 01.75-.75h10.5a.75.75 0 010 1.5H6.75a.75.75 0 01-.75-.75z"></path></svg>
                    <h3>도적</h3>
                    <p>민첩한 몸놀림으로 적의 급소를 노립니다.</p>
                </div>
            </div>
        </div>
        <div id="skill-selection-screen" class="game-screen overlay hidden">
            <h2 id="skill-select-title" class="text-4xl font-cinzel text-yellow-300 mb-10">초기 스킬을 선택하십시오 (0 / 3)</h2>
            <div id="starter-skills-container"></div>
            <button id="confirm-skills-btn" class="game-button" disabled>다음</button>
        </div>
        <div id="passive-skill-selection-screen" class="game-screen overlay hidden">
            <h2 id="passive-skill-select-title" class="text-4xl font-cinzel text-yellow-300 mb-10">패시브 스킬을 선택하십시오 (0 / 2)</h2>
            <div id="passive-skills-container"></div>
            <button id="confirm-passive-skills-btn" class="game-button" disabled>모험 시작</button>
        </div>
        <div id="battle-screen" class="game-screen hidden">
            <div id="battle-scene" class="battle-scene">
                <div id="vfx-container"></div>
                <div id="player" class="character player"><div id="player-sprite"></div></div>
                <div id="enemy" class="character enemy"><img id="enemy-img" src=""></div>
                
                <div class="ui-panel player-ui">
                    <div class="flex justify-between items-center">
                        <div class="flex items-center gap-2">
                            <h2 id="player-name" class="text-lg font-cinzel">플레이어</h2>
                            <span id="player-level" class="font-cinzel text-md text-yellow-300"></span>
                        </div>
                        <div class="menu-buttons">
                            <button id="char-menu-btn" class="menu-btn"><div class="notification-dot"></div><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2.5a5.5 5.5 0 0 1 5.5 5.5c0 1.58-.64 3.01-1.68 4.06a6.5 6.5 0 0 1-8.64 0A5.5 5.5 0 0 1 6.5 8 5.5 5.5 0 0 1 12 2.5zM12 14.5a9.5 9.5 0 0 1 9.5 9.5H2.5A9.5 9.5 0 0 1 12 14.5z"></path></svg></button>
                            <button id="skill-menu-btn" class="menu-btn"><div class="notification-dot"></div><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 18.6l-3.44 1.81 0.66-3.83-2.78-2.71 3.84-0.56L12 10l1.72 3.48 3.84 0.56-2.78 2.71 0.66 3.83L12 18.6zM12 2l-2.4 4.8-5.3 0.78 3.8 3.7-0.9 5.22L12 14.1l4.7 2.4-0.9-5.22 3.8-3.7-5.3-0.78L12 2z"></path></svg></button>
                        </div>
                    </div>
                    <div class="bar-container my-1"><div id="player-hp-bar" class="bar hp-bar"></div></div><p id="player-hp-text" class="text-right hp-text"></p><div class="bar-container my-1"><div id="player-mp-bar" class="bar mp-bar"></div></div><p id="player-mp-text" class="text-right mp-text"></p><div class="bar-container mt-1"><div id="player-xp-bar" class="bar xp-bar"></div></div>
                    <div id="player-buffs" class="buff-container"></div>
                </div>
                <div class="ui-panel enemy-ui">
                    <div class="flex justify-between items-center"><h2 id="enemy-name" class="text-lg font-cinzel"></h2><span id="stage-indicator" class="font-cinzel text-md text-red-400"></span></div>
                    <div class="bar-container my-1"><div id="enemy-hp-bar" class="bar hp-bar"></div></div><p id="enemy-hp-text" class="text-right hp-text"></p>
                    <div id="enemy-buffs" class="buff-container"></div>
                </div>

                <div id="log-panel" class="log-panel"><div id="log-messages-container"></div></div>
                
                <div class="controls">
                    <div id="skills-grid" class="skills-container"></div>
                </div>
            </div>
        </div>
        <div id="stage-clear-screen" class="game-screen overlay hidden"><h2 class="text-7xl font-cinzel text-blue-400 mb-6">VICTORY</h2><p id="xp-gain-text" class="text-xl text-purple-400 mb-10"></p><button id="next-stage-btn" class="game-button">다음 층으로</button></div>
        <div id="game-over-screen" class="game-screen overlay hidden"><h2 class="text-7xl font-cinzel text-red-500 mb-10">DEFEAT</h2><button id="restart-game-btn" class="game-button">다시 시작</button></div>
        <div id="game-clear-screen" class="game-screen overlay hidden"><h2 class="text-8xl font-cinzel text-yellow-300 mb-10">CONGRATULATIONS</h2><p class="text-2xl mb-12">조또 당신은 시련의 탑을 정복했습니다!</p><button id="play-again-btn" class="game-button">다시 플레이</button></div>

        <div id="character-modal" class="modal-overlay hidden"><div class="modal-content rounded-lg"><h2 class="text-3xl font-cinzel text-yellow-300 mb-6">캐릭터 정보</h2><div class="grid grid-cols-1 md:grid-cols-2 gap-8"><div><h3 class="text-xl font-bold mb-4">능력치 (남은 스탯: <span id="stat-points-display"></span>)</h3><div class="space-y-3"><div class="stat-row"><span>빠워 (STR)</span><div class="flex items-center gap-2"><button data-stat="str" class="stat-btn minus-btn">-</button><span id="stat-str" class="stat-value w-8"></span><button data-stat="str" class="stat-btn plus-btn">+</button></div></div><div class="stat-row"><span>능지 (INT)</span><div class="flex items-center gap-2"><button data-stat="int" class="stat-btn minus-btn">-</button><span id="stat-int" class="stat-value w-8"></span><button data-stat="int" class="stat-btn plus-btn">+</button></div></div><div class="stat-row"><span>재빠름(AGI)</span><div class="flex items-center gap-2"><button data-stat="agi" class="stat-btn minus-btn">-</button><span id="stat-agi" class="stat-value w-8"></span><button data-stat="agi" class="stat-btn plus-btn">+</button></div></div><div class="stat-row"><span>체력 (VIT)</span><div class="flex items-center gap-2"><button data-stat="vit" class="stat-btn minus-btn">-</button><span id="stat-vit" class="stat-value w-8"></span><button data-stat="vit" class="stat-btn plus-btn">+</button></div></div><div class="stat-row"><span>재수 (LUK)</span><div class="flex items-center gap-2"><button data-stat="luk" class="stat-btn minus-btn">-</button><span id="stat-luk" class="stat-value w-8"></span><button data-stat="luk" class="stat-btn plus-btn">+</button></div></div></div></div><div><h3 class="text-xl font-bold mb-4">상세 정보</h3><p>공격력: <span id="detail-atk"></span></p><p>방어력: <span id="detail-def"></span></p><p>최대 HP: <span id="detail-hp"></span></p><p>최대 MP: <span id="detail-mp"></span></p><p>치명타 확률: <span id="detail-crit-chance"></span>%</p><p>치명타 데미지: <span id="detail-crit-damage"></span>%</p></div></div><div class="flex justify-center gap-4 mt-8"><button id="confirm-stats-btn" class="game-button">변경사항 저장</button><button id="close-char-modal" class="game-button">닫기</button></div></div></div>
        <div id="skill-tree-modal" class="modal-overlay hidden"><div class="modal-content rounded-lg"><h2 class="text-3xl font-cinzel text-yellow-300 mb-6">스킬 (남은 포인트: <span id="skill-points"></span> | 패시브 포인트: <span id="passive-skill-points"></span>)</h2><div id="skill-tree-tabs" class="flex border-b border-gray-600 mb-4"></div><div id="skill-modal-layout"><div id="skill-list-panel"></div><div id="skill-details-panel"></div></div><div id="equipped-skills-container" class="mt-4"></div><button id="close-skill-modal" class="game-button mt-8">닫기</button></div></div>
    </div>

    <script type="module">
        const SPRITE_IMAGE_URL = 'https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/file_00000000685461f8ad0ef9b0754421cc.webp';
        const MAGE_SPRITE_URL = 'https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/file_00000000c82061f5880850490b718d78.webp';
        const ROGUE_SPRITE_URL = 'https://mbjwjkvaksucinhowody.supabase.co/storage/v1/object/public/xxx/dodook.webp';
        const SUNDER_VFX_URL = 'https://mbjwjkvaksucinhowody.supabase.co/storage/v1/object/public/xxx/sunderskil.webp';
        const WARRIOR_SPRITE_URL = 'https://mbjwjkvaksucinhowody.supabase.co/storage/v1/object/public/xxx/gisa.webp';
        
        const MAGE_SPRITE_DATA = { "meta": { "size": { "w": 1536, "h": 1024 } }, "sprites": [ { "name": "sprite_1", "x": 53, "y": 118, "w": 269, "h": 378 }, { "name": "sprite_2", "x": 384, "y": 127, "w": 312, "h": 367 }, { "name": "sprite_3", "x": 713, "y": 140, "w": 727, "h": 353 } ], "animations": { "attack": { "frames": [ 0, 1, 2 ], "fps": 8 } } };
        const ROGUE_SPRITE_DATA = { "meta": { "image": "dodook.webp", "size": { "w": 1536, "h": 1024 } }, "sprites": [ { "name": "sprite_1", "x": 31, "y": 120, "w": 266, "h": 386 }, { "name": "sprite_2", "x": 346, "y": 128, "w": 305, "h": 372 }, { "name": "sprite_3", "x": 693, "y": 128, "w": 307, "h": 370 }, { "name": "sprite_4", "x": 1015, "y": 128, "w": 490, "h": 371 }, { "name": "sprite_5", "x": 32, "y": 544, "w": 272, "h": 384 }, { "name": "sprite_6", "x": 352, "y": 544, "w": 296, "h": 382 }, { "name": "sprite_7", "x": 1070, "y": 544, "w": 427, "h": 382 }, { "name": "sprite_8", "x": 696, "y": 547, "w": 296, "h": 378 } ], "animations": { "attack": { "frames": [0, 1, 2, 3, 4, 5, 6, 7], "fps": 12 } } };
        const SUNDER_VFX_DATA = { "meta": { "image": "sunderskil.webp", "size": { "w": 1536, "h": 1024 } }, "sprites": [ { "name": "sprite_1", "x": 595, "y": 10, "w": 189, "h": 496 }, { "name": "sprite_2", "x": 890, "y": 13, "w": 219, "h": 975 }, { "name": "sprite_3", "x": 1280, "y": 64, "w": 120, "h": 441 }, { "name": "sprite_4", "x": 618, "y": 113, "w": 15, "h": 15 }, { "name": "sprite_5", "x": 1036, "y": 114, "w": 22, "h": 30 }, { "name": "sprite_6", "x": 372, "y": 166, "w": 9, "h": 18 }, { "name": "sprite_7", "x": 709, "y": 176, "w": 45, "h": 66 }, { "name": "sprite_8", "x": 369, "y": 184, "w": 57, "h": 320 }, { "name": "sprite_9", "x": 580, "y": 205, "w": 12, "h": 14 }, { "name": "sprite_10", "x": 757, "y": 239, "w": 24, "h": 16 }, { "name": "sprite_11", "x": 1081, "y": 246, "w": 8, "h": 10 }, { "name": "sprite_12", "x": 1395, "y": 258, "w": 10, "h": 14 }, { "name": "sprite_13", "x": 1269, "y": 259, "w": 12, "h": 8 }, { "name": "sprite_14", "x": 736, "y": 319, "w": 8, "h": 9 }, { "name": "sprite_15", "x": 1276, "y": 376, "w": 16, "h": 16 }, { "name": "sprite_16", "x": 1084, "y": 377, "w": 31, "h": 38 }, { "name": "sprite_17", "x": 1357, "y": 384, "w": 8, "h": 15 }, { "name": "sprite_18", "x": 80, "y": 392, "w": 15, "h": 40 }, { "name": "sprite_19", "x": 912, "y": 403, "w": 10, "h": 9 }, { "name": "sprite_20", "x": 1040, "y": 415, "w": 14, "h": 21 }, { "name": "sprite_21", "x": 74, "y": 424, "w": 46, "h": 80 }, { "name": "sprite_22", "x": 421, "y": 432, "w": 11, "h": 22 }, { "name": "sprite_23", "x": 54, "y": 472, "w": 10, "h": 8 }, { "name": "sprite_24", "x": 607, "y": 536, "w": 172, "h": 452 }, { "name": "sprite_25", "x": 928, "y": 538, "w": 9, "h": 14 }, { "name": "sprite_26", "x": 608, "y": 560, "w": 8, "h": 8 }, { "name": "sprite_27", "x": 615, "y": 565, "w": 34, "h": 51 }, { "name": "sprite_28", "x": 1039, "y": 569, "w": 25, "h": 31 }, { "name": "sprite_29", "x": 361, "y": 579, "w": 95, "h": 402 }, { "name": "sprite_30", "x": 1012, "y": 591, "w": 13, "h": 27 }, { "name": "sprite_31", "x": 640, "y": 596, "w": 24, "h": 20 }, { "name": "sprite_32", "x": 947, "y": 606, "w": 31, "h": 28 }, { "name": "sprite_33", "x": 1064, "y": 615, "w": 38, "h": 20 }, { "name": "sprite_34", "x": 76, "y": 632, "w": 52, "h": 342 }, { "name": "sprite_35", "x": 752, "y": 636, "w": 13, "h": 10 }, { "name": "sprite_36", "x": 334, "y": 638, "w": 23, "h": 30 }, { "name": "sprite_37", "x": 418, "y": 650, "w": 14, "h": 30 }, { "name": "sprite_38", "x": 354, "y": 707, "w": 13, "h": 19 }, { "name": "sprite_39", "x": 590, "y": 717, "w": 19, "h": 19 }, { "name": "sprite_40", "x": 581, "y": 736, "w": 8, "h": 13 }, { "name": "sprite_41", "x": 326, "y": 744, "w": 10, "h": 9 }, { "name": "sprite_42", "x": 1037, "y": 746, "w": 13, "h": 12 }, { "name": "sprite_43", "x": 336, "y": 752, "w": 16, "h": 23 }, { "name": "sprite_44", "x": 705, "y": 760, "w": 8, "h": 15 }, { "name": "sprite_45", "x": 707, "y": 773, "w": 8, "h": 36 }, { "name": "sprite_46", "x": 164, "y": 780, "w": 10, "h": 9 }, { "name": "sprite_47", "x": 150, "y": 791, "w": 12, "h": 21 }, { "name": "sprite_48", "x": 142, "y": 808, "w": 9, "h": 23 }, { "name": "sprite_49", "x": 327, "y": 811, "w": 16, "h": 21 }, { "name": "sprite_50", "x": 342, "y": 838, "w": 43, "h": 73 }, { "name": "sprite_51", "x": 651, "y": 844, "w": 11, "h": 36 }, { "name": "sprite_52", "x": 324, "y": 882, "w": 36, "h": 48 }, { "name": "sprite_53", "x": 128, "y": 896, "w": 22, "h": 42 }, { "name": "sprite_54", "x": 454, "y": 897, "w": 26, "h": 23 }, { "name": "sprite_55", "x": 748, "y": 899, "w": 21, "h": 24 }, { "name": "sprite_56", "x": 110, "y": 902, "w": 13, "h": 34 }, { "name": "sprite_57", "x": 413, "y": 903, "w": 18, "h": 17 }, { "name": "sprite_58", "x": 447, "y": 920, "w": 12, "h": 17 }, { "name": "sprite_59", "x": 969, "y": 920, "w": 12, "h": 21 }, { "name": "sprite_60", "x": 1039, "y": 921, "w": 8, "h": 15 }, { "name": "sprite_61", "x": 648, "y": 951, "w": 16, "h": 16 }, { "name": "sprite_62", "x": 1025, "y": 953, "w": 22, "h": 18 } ], "animations": { "sunder": { "frames": [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61], "fps": 24 } } };
        const WARRIOR_SPRITE_DATA = {
            "meta": { "image": "gisa.webp", "size": { "w": 1024, "h": 1024 } },
            "sprites": [
                { "name": "frame_1", "x": 336, "y": 36, "w": 291, "h": 316 },
                { "name": "frame_2", "x": 655, "y": 44, "w": 345, "h": 308 },
                { "name": "frame_3", "x": 27, "y": 47, "w": 286, "h": 305 },
                { "name": "frame_4", "x": 24, "y": 383, "w": 235, "h": 291 }
            ],
            "animations": { "attack": { "frames": [0, 1, 2, 3], "fps": 8 } }
        };

        const spriteData = {
            "meta": { "size": { "w": 1536, "h": 1024 } },
            "sprites": [{"name":"sprite_1","x":111,"y":64,"w":250,"h":242},{"name":"sprite_2","x":894,"y":64,"w":237,"h":242},{"name":"sprite_3","x":377,"y":65,"w":240,"h":241},{"name":"sprite_4","x":1152,"y":65,"w":240,"h":239},{"name":"sprite_5","x":635,"y":66,"w":237,"h":238},{"name":"sprite_6","x":112,"y":320,"w":249,"h":237},{"name":"sprite_7","x":894,"y":320,"w":238,"h":237},{"name":"sprite_8","x":636,"y":321,"w":236,"h":236},{"name":"sprite_9","x":1152,"y":321,"w":240,"h":237},{"name":"sprite_10","x":378,"y":322,"w":239,"h":235},{"name":"sprite_12","x":894,"y":573,"w":238,"h":232},{"name":"sprite_13","x":111,"y":576,"w":250,"h":230},{"name":"sprite_14","x":378,"y":576,"w":238,"h":231},{"name":"sprite_16","x":636,"y":576,"w":237,"h":228},{"name":"sprite_17","x":1152,"y":576,"w":240,"h":228},{"name":"sprite_20","x":1152,"y":822,"w":240,"h":202},{"name":"sprite_21","x":110,"y":823,"w":251,"h":201},{"name":"sprite_22","x":378,"y":823,"w":239,"h":201},{"name":"sprite_23","x":635,"y":823,"w":237,"h":201},{"name":"sprite_24","x":894,"y":823,"w":238,"h":201}]
        };

        const SKILLS = {
            basic_attack: { name: "기본 공격", type: "attack", cost: 0, scale: { str: 1.6 }, vfx: "slash", icon: "sprite_21", desc: "MP를 소모하지 않는 기본 공격입니다." },
            knight_bash: { name: "강타", type: "attack", cost: 8, scale: { str: 2.4 }, vfx: "slash", icon: "sprite_6", desc: "기본적인 공격입니다.", tier: 1, permanentBoost: { str_percent: 0.01 } },
            knight_shield_slam: { name: "방패 강타", type: "attack", cost: 15, scale: { str: 3.6, def: 1.0 }, vfx: "slash", icon: "sprite_10", desc: "방어력에 비례한 추가 피해를 줍니다.", tier: 2, requires: 'knight_bash', permanentBoost: { def_percent: 0.02 } },
            knight_whirlwind: { name: "휠윈드", type: "attack", cost: 28, scale: { str: 6.0 }, vfx: "slash", icon: "sprite_14", desc: "강력한 회전 공격입니다.", tier: 3, requires: 'knight_shield_slam', permanentBoost: { str_percent: 0.03 } },
            knight_ultimate: { name: "아발론의 가호", type: "buff", cost: 40, duration: 5, effects: { def: 2.0 }, vfx: "holy", icon: "sprite_17", desc: "5턴간 방어력이 100% 증가합니다.", tier: 4, requires: 'knight_whirlwind', permanentBoost: { maxHp_percent: 0.05 } },
            mage_fireball: { name: "파이어볼", type: "attack", cost: 12, scale: { int: 3.0 }, vfx: "fireball", icon: "sprite_8", desc: "작은 화염구를 날립니다.", tier: 1, permanentBoost: { int_percent: 0.01 } },
            mage_ice_spear: { name: "아이스 스피어", type: "attack", cost: 20, scale: { int: 5.0 }, vfx: "ice_shard", icon: "sprite_12", desc: "얼음 창으로 적을 꿰뚫습니다.", tier: 2, requires: 'mage_fireball', permanentBoost: { int_percent: 0.02 } },
            mage_chain_lightning: { name: "체인 라이트닝", type: "attack", cost: 32, scale: { int: 8.0 }, vfx: "lightning", icon: "sprite_5", desc: "전격으로 큰 피해를 줍니다.", tier: 3, requires: 'mage_ice_spear', permanentBoost: { int_percent: 0.03 } },
            mage_ultimate: { name: "메테오", type: "attack", cost: 65, scale: { int: 16.0 }, vfx: "fireball", icon: "sprite_9", desc: "거대한 운석을 떨어뜨립니다.", tier: 4, requires: 'mage_chain_lightning', permanentBoost: { maxMp_percent: 0.05 } },
            assassin_quick_stab: { name: "급소 찌르기", type: "attack", cost: 10, scale: { agi: 2.6 }, vfx: "slash", icon: "sprite_16", desc: "민첩한 공격을 가합니다.", tier: 1, permanentBoost: { agi_percent: 0.01 } },
            assassin_poison_blade: { name: "독 칼날", type: "attack", cost: 18, scale: { agi: 4.0 }, addEffect: { type: 'poison', chance: 0.5, duration: 3, power: 0.5 }, vfx: "slash", icon: "sprite_2", desc: "50% 확률로 3턴간 중독시킵니다.", tier: 2, requires: 'assassin_quick_stab', permanentBoost: { agi_percent: 0.02 } },
            assassin_shadow_strike: { name: "그림자 습격", type: "attack", cost: 30, scale: { agi: 7.0 }, addEffect: { type: 'bleed', chance: 0.3, duration: 2, power: 1.0 }, vfx: "shadow_strike", icon: "sprite_23", desc: "30% 확률로 2턴간 출혈을 일으킵니다.", tier: 3, requires: 'assassin_poison_blade', permanentBoost: { critChance: 1 } },
            assassin_ultimate: { name: "필살", type: "attack", cost: 45, scale: { agi: 12.0 }, vfx: "shadow_strike", icon: "sprite_20", desc: "적의 약점을 노려 치명타를 가합니다.", tier: 4, requires: 'assassin_shadow_strike', permanentBoost: { critDamage: 5 } },
            enemy_bash: { name: "몸통박치기", type: "attack", scale: 1.0, vfx: "slash" },
            enemy_quick_stab: { name: "단검 찌르기", type: "attack", scale: 1.2, vfx: "slash" },
            enemy_rage_smash: { name: "분노의 강타", type: "attack", scale: 1.5, vfx: "slash" },
            enemy_ambush: { name: "기습", type: "attack", scale: 1.8, vfx: "shadow_strike" },
            enemy_rock_throw: { name: "암석 투척", type: "attack", scale: 1.3, vfx: "slash" },
            enemy_earthquake: { name: "지진", type: "attack", scale: 2.0, vfx: "slash" },
            enemy_wing_slash: { name: "날개 베기", type: "attack", scale: 1.6, vfx: "slash" },
            enemy_scream: { name: "비명", type: "attack", scale: 2.5, vfx: "shadow_strike" },
            enemy_soul_drain: { name: "영혼 흡수", type: "attack", scale: 2.0, vfx: "shadow_strike" },
            enemy_death_grip: { name: "죽음의 손아귀", type: "attack", scale: 3.0, vfx: "shadow_strike" },
            enemy_flame_breath: { name: "화염 숨결", type: "attack", scale: 2.5, vfx: "fireball" },
            enemy_poison_fang: { name: "독 송곳니", type: "attack", scale: 2.2, vfx: "slash" },
            enemy_tentacle: { name: "촉수 공격", type: "attack", scale: 2.2, vfx: "slash" },
            enemy_void_blast: { name: "공허 폭발", type: "attack", scale: 3.5, vfx: "shadow_strike" },
            enemy_doom_blade: { name: "파멸의 검", type: "attack", scale: 3.0, vfx: "slash" },
            enemy_judgment: { name: "천벌", type: "attack", scale: 5.0, vfx: "holy" },
        };
        const SKILL_TREES = {
            warrior: { name: "전사", skills: [["knight_bash"], ["knight_shield_slam"], ["knight_whirlwind"], ["knight_ultimate"]] },
            mage: { name: "마법사", skills: [["mage_fireball"], ["mage_ice_spear"], ["mage_chain_lightning"], ["mage_ultimate"]] },
            rogue: { name: "도적", skills: [["assassin_quick_stab"], ["assassin_poison_blade"], ["assassin_shadow_strike"], ["assassin_ultimate"]] }
        };
        const PASSIVE_SKILLS = {
            warrior: {
                overpower: { name: "압도", icon: "sprite_6", maxLevel: 5, desc: level => `힘(STR)이 ${level * 5}% 증가합니다.`, effects: { str_percent: 0.05 } },
                weapon_mastery: { name: "무기 숙련", icon: "sprite_21", maxLevel: 5, desc: level => `기본 공격력이 ${level * 4}% 증가합니다.`, effects: { attack_percent: 0.04 } },
                adrenaline: { name: "아드레날린", icon: "sprite_1", maxLevel: 3, desc: level => `HP가 30% 이하일 때 공격력이 ${level * 10}% 증가합니다.`, effects: {} },
                toughness: { name: "강인함", icon: "sprite_10", maxLevel: 5, desc: level => `최대 HP가 ${level * 5}% 증가합니다.`, effects: { maxHp_percent: 0.05 } },
                counter_attack: { name: "반격", icon: "sprite_14", maxLevel: 3, desc: level => `피격 시 ${level * 5}% 확률로 반격합니다.`, effects: {} },
            },
            mage: {
                mana_font: { name: "마나 샘", icon: "sprite_7", maxLevel: 5, desc: level => `턴 시작 시 MP 회복량이 ${level * 3}% 증가합니다.`, effects: { regen_percent: 0.03 } },
                arcane_intellect: { name: "비전 지능", icon: "sprite_5", maxLevel: 5, desc: level => `지능(INT)이 ${level * 5}% 증가합니다.`, effects: { int_percent: 0.05 } },
                elementalist: { name: "원소 전문가", icon: "sprite_8", maxLevel: 3, desc: level => `모든 스킬의 공격력이 ${level * 5}% 증가합니다.`, effects: { all_damage_percent: 0.05 } },
                mana_shield: { name: "마나 보호막", icon: "sprite_12", maxLevel: 5, desc: level => `받는 피해의 ${level * 4}%를 MP로 대신 받습니다.`, effects: {} },
                concentration: { name: "집중", icon: "sprite_9", maxLevel: 3, desc: level => `스킬의 MP 소모량이 ${level * 5}% 감소합니다.`, effects: { cost_reduction_percent: 0.05 } },
            },
            rogue: {
                fleet_footed: { name: "질풍", icon: "sprite_16", maxLevel: 5, desc: level => `민첩(AGI) 20당 ${level * 0.5}% 확률로 추가 턴을 얻습니다.`, effects: {} },
                lethality: { name: "치명성", icon: "sprite_20", maxLevel: 5, desc: level => `치명타 피해량이 ${level * 10}% 증가합니다.`, effects: { critDamage: 10 } },
                venom: { name: "맹독", icon: "sprite_2", maxLevel: 3, desc: level => `공격 시 ${level * 5}% 확률로 적을 중독시킵니다.`, effects: {} },
                evasion: { name: "회피", icon: "sprite_23", maxLevel: 5, desc: level => `${level * 2}% 확률로 적의 공격을 회피합니다.`, effects: {} },
                opportunist: { name: "약점 포착", icon: "sprite_4", maxLevel: 3, desc: level => `상태 이상에 걸린 적에게 ${level * 10}% 추가 피해를 줍니다.`, effects: {} },
            }
        };
        const COMBOS = [
            { id: 'explosive_smash', name: '폭발 강타', skills: ['knight_bash', 'mage_fireball'], type: 'attack', scale: { str: 2.0, int: 2.0 }, vfx: 'fireball', desc: "'강타' 후 '파이어볼' 사용 시 발동. 물리/마법 피해를 동시에 줍니다." },
        ];
        const defaultBg = 'https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/file_00000000497c61fa963025bb3510d7bb_copy_1152x768.webp';
        const bossBg = 'https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/file_00000000ee64622f8f560adf6ed8ad9e.webp';
        const STAGES = [
            { name: "동굴 슬라임", img: "https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/file_0000000063c46246bee6c5711f863e5f.webp", bg: defaultBg, maxHp: 300, attack: 20, defense: 10, xp: 50, skills: [{ id: "enemy_bash" }] },
            { name: "고블린", img: "https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/file_00000000a02461fdba091ea7bb7d17f0.webp", bg: defaultBg, maxHp: 550, attack: 35, defense: 15, xp: 70, skills: [{ id: "enemy_quick_stab" }] },
            { name: "오우거", img: "https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/file_000000007a1861f59566d6a1c9ec3efd.webp", bg: defaultBg, maxHp: 1000, attack: 55, defense: 30, xp: 120, skills: [{ id: "enemy_rage_smash" }] },
            { name: "변이 늑대", img: "https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/file_000000003ba461f78d98d364bee72b77.webp", bg: defaultBg, maxHp: 900, attack: 80, defense: 25, xp: 150, skills: [{ id: "enemy_ambush" }] },
            { name: "골렘", img: "https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/file_00000000c4c061f8b39ab285d7781ae6.webp", bg: defaultBg, maxHp: 2500, attack: 65, defense: 80, xp: 200, skills: [{ id: "enemy_rock_throw" }, { id: "enemy_earthquake" }] },
            { name: "하피", img: "https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/file_0000000076c061fd8158be4983e0af69.webp", bg: defaultBg, maxHp: 1800, attack: 100, defense: 40, xp: 250, skills: [{ id: "enemy_wing_slash" }, { id: "enemy_scream" }] },
            { name: "흑마법사", img: "https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/file_0000000043bc61f7ac1fc49a00e6d658.webp", bg: defaultBg, maxHp: 2200, attack: 125, defense: 45, xp: 320, skills: [{ id: "enemy_soul_drain" }, { id: "enemy_death_grip" }] },
            { name: "해골 기사", img: "https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/file_00000000845861f58269c10b4859ac0d.webp", bg: defaultBg, maxHp: 3000, attack: 115, defense: 55, xp: 400, skills: [{ id: "enemy_rage_smash" }, { id: "enemy_doom_blade" }] },
            { name: "변이 괴물", img: "https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/file_0000000001a861fa835a0405826b25d7_copy_768x1152.png", bg: defaultBg, maxHp: 4000, attack: 140, defense: 70, xp: 500, skills: [{ id: "enemy_tentacle" }, { id: "enemy_void_blast" }] },
            { name: "고대 용", img: "https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/file_000000008b60622f9a53cc299a4d59d9.webp", bg: bossBg, maxHp: 8000, attack: 180, defense: 100, xp: 0, skills: [{ id: "enemy_doom_blade" }, { id: "enemy_judgment" }] }
        ];
        const STARTER_SKILL_POOLS = {
            warrior: { name: "전사", skills: ['knight_bash', 'knight_shield_slam', 'knight_whirlwind', 'knight_ultimate'] },
            mage: { name: "마법사", skills: ['mage_fireball', 'mage_ice_spear', 'mage_chain_lightning', 'mage_ultimate'] },
            rogue: { name: "도적", skills: ['assassin_quick_stab', 'assassin_poison_blade', 'assassin_shadow_strike', 'assassin_ultimate'] }
        };

        let gameState = {};
        let enemy = {};
        let isPlayerTurn = true;
        let isBattleOver = false;
        let selectedClassName = '';
        let selectedSkills = [];
        let selectedPassiveSkills = [];
        const MAX_SKILLS = 3;
        const MAX_PASSIVE_SKILLS = 2;
        let tempStats = {};
        let initialStats = {};
        const sounds = {};
        let animationInterval = null;

        function applyPassiveEffects(player) {
            if (!player.stats) { 
                return { attack: player.attack, defense: player.defense };
            }

            let modifiedStats = {
                stats: { ...player.stats },
                maxHp: 250 + (player.level * 25) + (player.stats.vit * 20),
                maxMp: 100 + (player.level * 10) + (player.stats.int * 10),
                attack: 20 + (player.stats.str * 2) + Math.floor(player.stats.agi * 1.5),
                defense: 10 + (player.stats.str * 1) + Math.floor(player.stats.agi * 0.5) + (player.stats.vit * 2),
                critChance: 10 + (player.stats.luk * 0.8),
                critDamage: 180 + (player.stats.luk * 2.5),
                regen_percent: 0.05
            };

            player.learnedSkills.forEach(skillId => {
                const boost = SKILLS[skillId].permanentBoost;
                if (boost) {
                    if (boost.str_percent) modifiedStats.stats.str *= (1 + boost.str_percent);
                    if (boost.int_percent) modifiedStats.stats.int *= (1 + boost.int_percent);
                    if (boost.agi_percent) modifiedStats.stats.agi *= (1 + boost.agi_percent);
                    if (boost.maxHp_percent) modifiedStats.maxHp *= (1 + boost.maxHp_percent);
                    if (boost.maxMp_percent) modifiedStats.maxMp *= (1 + boost.maxMp_percent);
                    if (boost.critChance) modifiedStats.critChance += boost.critChance;
                    if (boost.critDamage) modifiedStats.critDamage += boost.critDamage;
                }
            });

            for (const skillId in player.passiveSkills) {
                const level = player.passiveSkills[skillId];
                const passive = PASSIVE_SKILLS[selectedClassName][skillId];
                if (passive.effects.maxHp_percent) modifiedStats.maxHp *= (1 + passive.effects.maxHp_percent * level);
                if (passive.effects.maxMp_percent) modifiedStats.maxMp *= (1 + passive.effects.maxMp_percent * level);
                if (passive.effects.str) modifiedStats.stats.str += passive.effects.str * level;
                if (passive.effects.critChance) modifiedStats.critChance += passive.effects.critChance * level;
                if (passive.effects.critDamage) modifiedStats.critDamage += passive.effects.critDamage * level;
                if (passive.effects.regen_percent) modifiedStats.regen_percent += passive.effects.regen_percent * level;
                if (passive.effects.str_percent) modifiedStats.stats.str *= (1 + passive.effects.str_percent * level);
                if (passive.effects.int_percent) modifiedStats.stats.int *= (1 + passive.effects.int_percent * level);
            }
            
            modifiedStats.attack = 20 + (modifiedStats.stats.str * 2) + Math.floor(modifiedStats.stats.agi * 1.5);
            modifiedStats.defense = 10 + (modifiedStats.stats.str * 1) + Math.floor(modifiedStats.stats.agi * 0.5) + (modifiedStats.stats.vit * 2);

            return modifiedStats;
        }

        function createInitialPlayerState() {
            const player = {
                level: 1, xp: 0, xpToNextLevel: 100,
                stats: { str: 5, int: 5, agi: 5, vit: 5, luk: 5 },
                statPoints: 0, skillPoints: 1, passiveSkillPoints: 0,
                learnedSkills: [],
                equippedSkills: Array(10).fill(null),
                skillLevels: {},
                passiveSkills: {},
                comboHistory: [],
                activeBuffs: [],
                statusEffects: [],
            };
            
            const stateProxy = new Proxy(player, {
                get(target, prop) {
                    if (['maxHp', 'maxMp', 'attack', 'defense', 'critChance', 'critDamage', 'regen_percent'].includes(prop)) {
                        const calculatedStats = applyPassiveEffects(target);
                        return calculatedStats[prop];
                    }
                    return target[prop];
                }
            });

            stateProxy.learnedSkills.forEach(id => stateProxy.skillLevels[id] = 1);
            stateProxy.currentHp = stateProxy.maxHp;
            stateProxy.currentMp = stateProxy.maxMp;
            return stateProxy;
        }

        const dom = {
            screens: { loading: document.getElementById('loading-screen'), title: document.getElementById('title-screen'), classSelection: document.getElementById('class-selection-screen'), skillSelection: document.getElementById('skill-selection-screen'), passiveSkillSelection: document.getElementById('passive-skill-selection-screen'), battle: document.getElementById('battle-screen'), stageClear: document.getElementById('stage-clear-screen'), gameOver: document.getElementById('game-over-screen'), gameClear: document.getElementById('game-clear-screen') },
            modals: { character: document.getElementById('character-modal'), skillTree: document.getElementById('skill-tree-modal') },
            skillSelection: { title: document.getElementById('skill-select-title'), container: document.getElementById('starter-skills-container'), confirmBtn: document.getElementById('confirm-skills-btn') },
            passiveSkillSelection: { title: document.getElementById('passive-skill-select-title'), container: document.getElementById('passive-skills-container'), confirmBtn: document.getElementById('confirm-passive-skills-btn') },
            logContainer: document.getElementById('log-messages-container'),
            vfxContainer: document.getElementById('vfx-container'),
            player: { el: document.getElementById('player'), sprite: document.getElementById('player-sprite'), name: document.getElementById('player-name'), level: document.getElementById('player-level'), hpBar: document.getElementById('player-hp-bar'), hpText: document.getElementById('player-hp-text'), mpBar: document.getElementById('player-mp-bar'), mpText: document.getElementById('player-mp-text'), xpBar: document.getElementById('player-xp-bar'), buffs: document.getElementById('player-buffs') },
            enemy: { el: document.getElementById('enemy'), img: document.getElementById('enemy-img'), name: document.getElementById('enemy-name'), hpBar: document.getElementById('enemy-hp-bar'), hpText: document.getElementById('enemy-hp-text'), stage: document.getElementById('stage-indicator'), buffs: document.getElementById('enemy-buffs') },
            controls: { skills: document.getElementById('skills-grid') },
            charModal: { points: document.getElementById('stat-points-display'), str: document.getElementById('stat-str'), int: document.getElementById('stat-int'), agi: document.getElementById('stat-agi'), vit: document.getElementById('stat-vit'), luk: document.getElementById('stat-luk'), atk: document.getElementById('detail-atk'), def: document.getElementById('detail-def'), hp: document.getElementById('detail-hp'), mp: document.getElementById('detail-mp'), critChance: document.getElementById('detail-crit-chance'), critDamage: document.getElementById('detail-crit-damage'), confirmBtn: document.getElementById('confirm-stats-btn') },
            skillModal: { 
                points: document.getElementById('skill-points'), 
                passivePoints: document.getElementById('passive-skill-points'), 
                tabs: document.getElementById('skill-tree-tabs'), 
                layout: document.getElementById('skill-modal-layout'),
                listPanel: document.getElementById('skill-list-panel'),
                detailsPanel: document.getElementById('skill-details-panel'),
                equippedSkills: document.getElementById('equipped-skills-container') 
            },
        };

        function setupSounds() {
            sounds.click = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
            sounds.slash = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.01, decay: 0.15, sustain: 0, release: 0.1 } }).toDestination();
            sounds.fireball = new Tone.Synth({ oscillator: { type: 'fmsquare', modulationType: 'sawtooth', modulationIndex: 2 }, envelope: { attack: 0.05, decay: 0.3, sustain: 0.1, release: 0.4 } }).toDestination();
            sounds.ice_shard = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.2 } }).toDestination();
            sounds.holy = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'sine' }, envelope: { attack: 0.1, decay: 0.5, sustain: 0.2, release: 0.5 } }).toDestination();
            sounds.heal = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.2, decay: 0.3, sustain: 0.4, release: 0.5 } }).toDestination();
            sounds.damage = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.2 } }).toDestination();
            sounds.levelUp = new Tone.PolySynth(Tone.Synth).toDestination();
            sounds.victory = new Tone.PolySynth(Tone.Synth).toDestination();
            sounds.defeat = new Tone.PolySynth(Tone.Synth).toDestination();
        }

        function playSound(effect) {
            if (!sounds[effect] || Tone.context.state !== 'running') return;
            const now = Tone.now();
            switch (effect) {
                case 'click': sounds.click.triggerAttackRelease('C5', '8n', now); break;
                case 'slash': sounds.slash.triggerAttackRelease('4n', now); break;
                case 'fireball': sounds.fireball.triggerAttackRelease('G2', '8n', now); break;
                case 'ice_shard': sounds.ice_shard.triggerAttackRelease('C6', '16n', now); break;
                case 'holy': sounds.holy.triggerAttackRelease(['C4', 'E4', 'G4'], '2n', now); break;
                case 'heal': sounds.heal.triggerAttackRelease('A4', '4n', now); break;
                case 'damage': sounds.damage.triggerAttackRelease('C2', '8n', now); break;
                case 'levelUp': sounds.levelUp.triggerAttackRelease(['C4', 'E4', 'G4', 'C5'], '16n', now); break;
                case 'victory': sounds.victory.triggerAttackRelease(['C4', 'E4', 'G4'], '4n', now); setTimeout(() => sounds.victory.triggerAttackRelease(['G4', 'A4', 'C5'], '4n', Tone.now() + 0.3), 300); break;
                case 'defeat': sounds.defeat.triggerAttackRelease(['C4', 'D#4', 'G4'], '2n', now); break;
            }
        }

        function switchScreen(screenName) {
            Object.values(dom.screens).forEach(s => s.classList.add('hidden'));
            if (dom.screens[screenName]) {
                dom.screens[screenName].classList.remove('hidden');
                dom.screens[screenName].classList.add('fade-in');
            }
        }
        
        function showSkillSelection(className) {
            selectedClassName = className;
            selectedSkills = [];
            switchScreen('skillSelection');
            const skillPool = STARTER_SKILL_POOLS[className].skills;
            dom.skillSelection.container.innerHTML = '';
            const tempPlayer = { stats: { str: 5, int: 5, agi: 5 }, attack: 20 + (5 * 2) + Math.floor(5 * 1.5) };
            skillPool.forEach(skillId => {
                const skill = SKILLS[skillId];
                const sprite = spriteData.sprites.find(s => s.name === skill.icon);
                const card = document.createElement('div');
                card.className = 'skill-card rounded-lg';
                card.dataset.skillId = skillId;
                const SPRITE_SCALE_FACTOR = 3.5;
                const scaledWidth = spriteData.meta.size.w / SPRITE_SCALE_FACTOR;
                const scaledHeight = spriteData.meta.size.h / SPRITE_SCALE_FACTOR;
                const scaledX = sprite.x / SPRITE_SCALE_FACTOR;
                const scaledY = sprite.y / SPRITE_SCALE_FACTOR;
                
                let detailsHTML = `<p class="text-xs text-gray-400 mt-1">${skill.desc}</p><p class="text-xs text-blue-400 mt-2">MP 소모: ${skill.cost}</p>`;
                if (skill.type === 'attack' && skill.scale) {
                    const power = ((tempPlayer.attack * (skill.scale.str || 0)) + (tempPlayer.stats.int * 2.5 * (skill.scale.int || 0)) + (tempPlayer.stats.agi * 1.5 * (skill.scale.agi || 0)));
                    const minDamage = Math.floor(Math.max(10, power * 0.85));
                    const maxDamage = Math.floor(Math.max(10, power * 1.0));
                    detailsHTML += `<p class="text-xs text-red-400">예상 피해: ${minDamage}~${maxDamage}</p>`;
                }

                card.innerHTML = `<div class="w-16 h-16 mb-2 mx-auto overflow-hidden rounded-lg border-2 border-gray-600"><div class="skill-sprite-icon" style="background-image: url('${SPRITE_IMAGE_URL}'); background-size: ${scaledWidth}px ${scaledHeight}px; background-position: -${scaledX}px -${scaledY}px;"></div></div><h4 class="text-white">${skill.name}</h4>${detailsHTML}`;
                card.addEventListener('click', () => toggleSkillSelection(card, skillId));
                dom.skillSelection.container.appendChild(card);
            });
            updateSkillSelectionUI();
        }

        function toggleSkillSelection(card, skillId) {
            if (selectedSkills.includes(skillId)) {
                selectedSkills = selectedSkills.filter(id => id !== skillId);
                card.classList.remove('selected');
            } else {
                if (selectedSkills.length < MAX_SKILLS) {
                    selectedSkills.push(skillId);
                    card.classList.add('selected');
                }
            }
            updateSkillSelectionUI();
        }

        function updateSkillSelectionUI() {
            dom.skillSelection.title.textContent = `초기 스킬을 선택하십시오 (${selectedSkills.length} / ${MAX_SKILLS})`;
            dom.skillSelection.confirmBtn.disabled = selectedSkills.length !== MAX_SKILLS;
        }

        function showPassiveSkillSelection() {
            switchScreen('passiveSkillSelection');
            selectedPassiveSkills = [];
            const container = dom.passiveSkillSelection.container;
            container.innerHTML = '';
            Object.keys(PASSIVE_SKILLS[selectedClassName]).forEach(skillId => {
                const skill = PASSIVE_SKILLS[selectedClassName][skillId];
                const card = document.createElement('div');
                card.className = 'skill-card rounded-lg';
                card.dataset.skillId = skillId;
                card.innerHTML = `<h4 class="text-white">${skill.name}</h4><p>${skill.desc(1)}</p>`;
                card.addEventListener('click', () => togglePassiveSkillSelection(card, skillId));
                container.appendChild(card);
            });
            updatePassiveSkillSelectionUI();
        }

        function togglePassiveSkillSelection(card, skillId) {
            if (selectedPassiveSkills.includes(skillId)) {
                selectedPassiveSkills = selectedPassiveSkills.filter(id => id !== skillId);
                card.classList.remove('selected');
            } else {
                if (selectedPassiveSkills.length < MAX_PASSIVE_SKILLS) {
                    selectedPassiveSkills.push(skillId);
                    card.classList.add('selected');
                }
            }
            updatePassiveSkillSelectionUI();
        }

        function updatePassiveSkillSelectionUI() {
            dom.passiveSkillSelection.title.textContent = `패시브 스킬을 선택하십시오 (${selectedPassiveSkills.length} / ${MAX_PASSIVE_SKILLS})`;
            dom.passiveSkillSelection.confirmBtn.disabled = selectedPassiveSkills.length !== MAX_PASSIVE_SKILLS;
        }

        function startGame() {
            gameState = { player: createInitialPlayerState(), currentStage: 0 };
            gameState.player.learnedSkills = [...selectedSkills];
            gameState.player.equippedSkills = [...selectedSkills, ...Array(10 - selectedSkills.length).fill(null)];
            gameState.player.learnedSkills.forEach(id => gameState.player.skillLevels[id] = 1);
            selectedPassiveSkills.forEach(id => gameState.player.passiveSkills[id] = 1);
            
            gameState.player.currentHp = gameState.player.maxHp;
            gameState.player.currentMp = gameState.player.maxMp;

            const spriteEl = dom.player.sprite;
            if (selectedClassName === 'mage') {
                const sprite = MAGE_SPRITE_DATA.sprites[0];
                const scale = 0.8;
                spriteEl.style.backgroundImage = `url('${MAGE_SPRITE_URL}')`;
                spriteEl.style.backgroundSize = `${MAGE_SPRITE_DATA.meta.size.w * scale}px ${MAGE_SPRITE_DATA.meta.size.h * scale}px`;
                spriteEl.style.width = `${sprite.w * scale}px`;
                spriteEl.style.height = `${sprite.h * scale}px`;
                setSpriteFrame(spriteEl, MAGE_SPRITE_DATA, 0, scale);
            } else if (selectedClassName === 'rogue') {
                const maxWidth = Math.max(...ROGUE_SPRITE_DATA.sprites.map(s => s.w));
                const maxHeight = Math.max(...ROGUE_SPRITE_DATA.sprites.map(s => s.h));
                const scale = 0.6;
                spriteEl.style.backgroundImage = `url('${ROGUE_SPRITE_URL}')`;
                spriteEl.style.backgroundSize = `${ROGUE_SPRITE_DATA.meta.size.w * scale}px ${ROGUE_SPRITE_DATA.meta.size.h * scale}px`;
                spriteEl.style.width = `${maxWidth * scale}px`;
                spriteEl.style.height = `${maxHeight * scale}px`;
                setSpriteFrame(spriteEl, ROGUE_SPRITE_DATA, 0, scale);
            } else if (selectedClassName === 'warrior') {
                const maxWidth = Math.max(...WARRIOR_SPRITE_DATA.sprites.map(s => s.w));
                const maxHeight = Math.max(...WARRIOR_SPRITE_DATA.sprites.map(s => s.h));
                const scale = 0.8; 
                spriteEl.style.backgroundImage = `url('${WARRIOR_SPRITE_URL}')`;
                spriteEl.style.backgroundSize = `${WARRIOR_SPRITE_DATA.meta.size.w * scale}px ${WARRIOR_SPRITE_DATA.meta.size.h * scale}px`;
                spriteEl.style.width = `${maxWidth * scale}px`;
                spriteEl.style.height = `${maxHeight * scale}px`;
                setSpriteFrame(spriteEl, WARRIOR_SPRITE_DATA, 0, scale);
            }

            switchScreen('battle');
            loadStage(gameState.currentStage);
        }

        function loadStage(stageIndex) {
            isBattleOver = false; isPlayerTurn = true;
            const stageData = STAGES[stageIndex];
            enemy = { ...stageData, currentHp: stageData.maxHp, activeBuffs: [], statusEffects: [] };
            dom.enemy.img.src = enemy.img;
            dom.screens.battle.querySelector('.battle-scene').style.backgroundImage = `url('${stageData.bg}')`;
            updateAllUI();
            clearLogs();
            addLog(`제 ${stageIndex + 1}층: <span class="font-bold text-red-300">${enemy.name}</span>(이)가 나타났다!`);
        }

        function handleVictory() {
            isBattleOver = true;
            playSound('victory');
            const xpGained = STAGES[gameState.currentStage].xp;
            document.getElementById('xp-gain-text').textContent = `경험치 ${xpGained} XP 획득!`;
            setTimeout(() => {
                switchScreen('stageClear');
                gainXP(xpGained);
            }, 1500);
        }

        function handleDefeat() { isBattleOver = true; playSound('defeat'); setTimeout(() => switchScreen('gameOver'), 1500); }
        
        function gainXP(amount) {
            gameState.player.xp += amount;
            while (gameState.player.xp >= gameState.player.xpToNextLevel) {
                levelUp();
            }
            updatePlayerUI();
        }

        function levelUp() {
            const p = gameState.player;
            p.xp -= p.xpToNextLevel;
            p.level++;
            p.xpToNextLevel = Math.floor(p.xpToNextLevel * 1.5);
            p.statPoints += 10;
            p.skillPoints += 1;
            p.passiveSkillPoints += 2;
            p.currentHp = p.maxHp;
            p.currentMp = p.maxMp;
            addLog(`<strong class="text-xl font-cinzel text-yellow-300">LEVEL UP!</strong>`, 'text-yellow-300');
            playSound('levelUp');
            updateMenuButtonsNotification();
        }

        function updateAllUI() { updatePlayerUI(); updateEnemyUI(); setupSkillButtons(); updateMenuButtonsNotification(); }
        
        function updatePlayerUI() {
            const p = gameState.player;
            dom.player.level.textContent = `Lv. ${p.level}`;
            dom.player.hpText.textContent = `${Math.round(p.currentHp)}/${Math.round(p.maxHp)}`;
            dom.player.hpBar.style.width = `${(p.currentHp / p.maxHp) * 100}%`;
            dom.player.mpText.textContent = `${Math.round(p.currentMp)}/${Math.round(p.maxMp)}`;
            dom.player.mpBar.style.width = `${(p.currentMp / p.maxMp) * 100}%`;
            dom.player.xpBar.style.width = `${(p.xp / p.xpToNextLevel) * 100}%`;
            updateBuffUI(p, dom.player.buffs);
        }

        function updateEnemyUI() {
            if (!enemy) return;
            dom.enemy.name.textContent = enemy.name;
            dom.enemy.stage.textContent = `${gameState.currentStage + 1}F`;
            dom.enemy.hpText.textContent = `${Math.round(enemy.currentHp)}/${enemy.maxHp}`;
            dom.enemy.hpBar.style.width = `${(enemy.currentHp / enemy.maxHp) * 100}%`;
            updateBuffUI(enemy, dom.enemy.buffs);
        }

        function updateBuffUI(character, container) {
            container.innerHTML = '';
            const allEffects = [...character.activeBuffs, ...character.statusEffects];
            allEffects.forEach(effect => {
                const skill = SKILLS[effect.id] || { name: effect.type, icon: 'sprite_24' }; // Fallback for status effects
                const sprite = spriteData.sprites.find(s => s.name === skill.icon);
                const buffEl = document.createElement('div');
                buffEl.className = 'buff-icon';
                const SPRITE_SCALE_FACTOR = 10;
                const scaledWidth = spriteData.meta.size.w / SPRITE_SCALE_FACTOR;
                const scaledHeight = spriteData.meta.size.h / SPRITE_SCALE_FACTOR;
                const scaledX = sprite.x / SPRITE_SCALE_FACTOR;
                const scaledY = sprite.y / SPRITE_SCALE_FACTOR;
                buffEl.innerHTML = `<div class="skill-sprite-icon w-full h-full" style="background-image: url('${SPRITE_IMAGE_URL}'); background-size: ${scaledWidth}px ${scaledHeight}px; background-position: -${scaledX}px -${scaledY}px;"></div><span class="duration">${effect.duration}</span>`;
                container.appendChild(buffEl);
            });
        }
        
        function setupSkillButtons() {
            dom.controls.skills.innerHTML = '';
            const activeSkills = ['basic_attack', ...gameState.player.equippedSkills];
            const SPRITE_SCALE_FACTOR = 6.5;

            for(let i = 0; i < 11; i++) {
                const skillId = activeSkills[i];
                const button = document.createElement('button');
                button.className = 'skill-btn relative';
                if(skillId) {
                    const skill = getEffectiveSkill(skillId);
                    const sprite = spriteData.sprites.find(s => s.name === skill.icon);
                    const level = gameState.player.skillLevels[skillId] || 1;
                    const scaledWidth = spriteData.meta.size.w / SPRITE_SCALE_FACTOR;
                    const scaledHeight = spriteData.meta.size.h / SPRITE_SCALE_FACTOR;
                    const scaledX = sprite.x / SPRITE_SCALE_FACTOR;
                    const scaledY = sprite.y / SPRITE_SCALE_FACTOR;
                    button.innerHTML = `<div class="icon-wrapper"><div class="skill-sprite-icon" style="background-image: url('${SPRITE_IMAGE_URL}'); background-size: ${scaledWidth}px ${scaledHeight}px; background-position: -${scaledX}px -${scaledY}px;"></div></div><div class="skill-label"><span class="truncate">${skill.name}</span>${level > 1 ? `<span class="text-yellow-400">Lv.${level}</span>` : ''}</div><div class="tooltip"><p class="font-bold">${skill.name} ${level > 1 ? `(Lv.${level})` : ''}</p><p class="text-xs text-gray-300">${skill.desc}</p><p class="text-xs text-blue-400">MP 소모: ${skill.cost}</p></div>`;
                    
                    let pressTimer;
                    button.addEventListener('click', () => playerTurn(skillId));
                    if (i > 0) { // Basic attack cannot be unequipped
                        button.addEventListener('mousedown', () => {
                            pressTimer = setTimeout(() => {
                                unequipSkillFromSlot(i - 1);
                            }, 600);
                        });
                         button.addEventListener('mouseup', () => clearTimeout(pressTimer));
                         button.addEventListener('mouseleave', () => clearTimeout(pressTimer));
                         button.addEventListener('touchstart', (e) => { e.preventDefault(); pressTimer = setTimeout(() => unequipSkillFromSlot(i - 1), 600); });
                         button.addEventListener('touchend', () => clearTimeout(pressTimer));
                    }

                } else {
                    button.innerHTML = `<span></span>`;
                    button.disabled = true;
                }
                dom.controls.skills.appendChild(button);
            }
            toggleSkillButtons(isPlayerTurn ? false : true);
        }

        function unequipSkillFromSlot(slotIndex) {
            const skillId = gameState.player.equippedSkills[slotIndex];
            if (skillId) {
                gameState.player.equippedSkills[slotIndex] = null;
                addLog(`<span class="font-bold text-yellow-300">${SKILLS[skillId].name}</span> 스킬을 해제했습니다.`);
                setupSkillButtons();
            }
        }

        function clearLogs() { dom.logContainer.innerHTML = ''; }
        function addLog(message, color = 'text-gray-300') { 
            const logEl = document.createElement('div'); 
            logEl.className = `px-2 py-1 text-center ${color}`; 
            logEl.innerHTML = message; 
            dom.logContainer.prepend(logEl);
            if(dom.logContainer.children.length > 10) {
                dom.logContainer.lastChild.remove();
            }
        }
        
        function showDamageVFX(target, text, isCrit = false) {
            const vfxEl = document.createElement('div');
            const colorClass = text.startsWith('+') ? 'text-green-400' : 'text-red-500';
            vfxEl.className = `vfx-damage-text absolute ${colorClass} ${isCrit ? 'critical' : ''}`;
            vfxEl.textContent = text;
            const targetRect = target.getBoundingClientRect();
            const containerRect = dom.vfxContainer.getBoundingClientRect();
            vfxEl.style.left = `${targetRect.left - containerRect.left + targetRect.width / 2}px`;
            vfxEl.style.top = `${targetRect.top - containerRect.top}px`;
            dom.vfxContainer.appendChild(vfxEl);
            vfxEl.addEventListener('animationend', () => vfxEl.remove());
        }

        function playVFX(target, vfxType, source) { 
             const targetRect = target.getBoundingClientRect();
            const vfxEl = document.createElement('div');
            vfxEl.className = `vfx vfx-${vfxType}`;
            if (vfxType === 'heal') { for (let i = 0; i < 15; i++) { const p = document.createElement('div'); p.className = 'vfx-heal-particle'; p.style.left = `${targetRect.left + targetRect.width / 2 + (Math.random() - 0.5) * targetRect.width}px`; p.style.top = `${targetRect.top + targetRect.height * 0.8}px`; p.style.animationDelay = `${Math.random() * 0.5}s`; dom.vfxContainer.appendChild(p); p.addEventListener('animationend', () => p.remove()); } return; } else if (vfxType === 'fireball' || vfxType === 'ice_shard') { vfxEl.style.top = `${targetRect.top + targetRect.height * 0.3}px`; if(source === dom.player.el) { vfxEl.style.left = `${source.getBoundingClientRect().right}px`; vfxEl.style.setProperty('--travel-dist', `${targetRect.left - source.getBoundingClientRect().right}px`); } else { vfxEl.style.left = `${source.getBoundingClientRect().left}px`; vfxEl.style.setProperty('--travel-dist', `${targetRect.right - source.getBoundingClientRect().left}px`); } } else if (vfxType === 'lightning' || vfxType === 'holy') { vfxEl.style.left = `${targetRect.left + targetRect.width / 2 - (vfxType === 'holy' ? 100 : 5)}px`; vfxEl.style.top = `${targetRect.top - 50}px`; if(vfxType === 'lightning') vfxEl.style.height = `${targetRect.height + 50}px`; } else if (vfxType === 'dragon_breath') { vfxEl.style.left = `${source.getBoundingClientRect().right - 50}px`; vfxEl.style.top = `${source.getBoundingClientRect().top}px`; } else { vfxEl.style.left = `${targetRect.left + (targetRect.width / 2) - 75}px`; vfxEl.style.top = `${targetRect.top + (targetRect.height / 2) - 75}px`; }
            dom.vfxContainer.appendChild(vfxEl);
            vfxEl.addEventListener('animationend', () => vfxEl.remove());
        }

        function playSpriteVFX(target, vfxData, vfxUrl) {
            const vfxEl = document.createElement('div');
            vfxEl.className = 'vfx';
            const scale = 1.5; 
            const maxWidth = Math.max(...vfxData.sprites.map(s => s.w));
            const maxHeight = Math.max(...vfxData.sprites.map(s => s.h));
            
            vfxEl.style.width = `${maxWidth * scale}px`;
            vfxEl.style.height = `${maxHeight * scale}px`;
            vfxEl.style.backgroundImage = `url('${vfxUrl}')`;
            vfxEl.style.backgroundSize = `${vfxData.meta.size.w * scale}px ${vfxData.meta.size.h * scale}px`;
            
            const targetRect = target.getBoundingClientRect();
            vfxEl.style.left = `${targetRect.left + (targetRect.width / 2) - (maxWidth * scale / 2)}px`;
            vfxEl.style.top = `${targetRect.top + (targetRect.height / 2) - (maxHeight * scale / 2)}px`;
            
            dom.vfxContainer.appendChild(vfxEl);

            let currentFrame = 0;
            const animation = vfxData.animations.sunder;
            const interval = setInterval(() => {
                if (currentFrame >= animation.frames.length) {
                    clearInterval(interval);
                    vfxEl.remove();
                    return;
                }
                const frameIndex = animation.frames[currentFrame];
                const frame = vfxData.sprites[frameIndex];
                vfxEl.style.backgroundPosition = `-${frame.x * scale}px -${frame.y * scale}px`;
                currentFrame++;
            }, 1000 / animation.fps);
        }

        function getEffectiveSkill(skillId) {
            const baseSkill = { ...SKILLS[skillId] };
            const level = gameState.player.skillLevels[skillId] || 1;
            if (baseSkill.upgradeEffects) {
                for (let i = 2; i <= level; i++) {
                    if (baseSkill.upgradeEffects[i]) {
                        Object.assign(baseSkill, baseSkill.upgradeEffects[i]);
                    }
                }
            }
            return baseSkill;
        }

        function getEffectiveStats(character) {
            if (!character.stats) { // Enemy
                const stats = { attack: character.attack, defense: character.defense, immune: false };
                 character.activeBuffs.forEach(buff => {
                     const skill = SKILLS[buff.id];
                     if (skill.effects.atk) stats.attack *= skill.effects.atk;
                     if (skill.effects.def) stats.defense *= skill.effects.def;
                     if (skill.effects.immune) stats.immune = true;
                 });
                 return stats;
            }
            
            const effectiveStats = applyPassiveEffects(character); // Player
            character.activeBuffs.forEach(buff => {
                const skill = SKILLS[buff.id];
                if (skill.effects.atk) effectiveStats.attack *= skill.effects.atk;
                if (skill.effects.def) effectiveStats.defense *= skill.effects.def;
                if (skill.effects.immune) effectiveStats.immune = true;
            });
            return effectiveStats;
        }

        function setSpriteFrame(element, spriteData, frameIndex, scale = 1) {
            const frame = spriteData.sprites[frameIndex];
            if (frame) {
                // Rogue and Warrior sprites have different dimensions per frame
                if (spriteData === ROGUE_SPRITE_DATA || spriteData === WARRIOR_SPRITE_DATA) {
                     element.style.width = `${frame.w * scale}px`;
                     element.style.height = `${frame.h * scale}px`;
                }
                element.style.backgroundPosition = `-${frame.x * scale}px -${frame.y * scale}px`;
            }
        }

        function playSpriteAnimation(element, spriteData, animationName, scale = 1) {
            if (animationInterval) clearInterval(animationInterval);
            
            const animation = spriteData.animations[animationName];
            if (!animation) return;

            let currentFrameIndex = 0;
            animationInterval = setInterval(() => {
                const frameIndex = animation.frames[currentFrameIndex];
                setSpriteFrame(element, spriteData, frameIndex, scale);
                currentFrameIndex++;
                if (currentFrameIndex >= animation.frames.length) {
                    clearInterval(animationInterval);
                    animationInterval = null;
                    setSpriteFrame(element, spriteData, 0, scale);
                }
            }, 1000 / animation.fps);
        }

        function performAction(attacker, defender, skillId, isCombo = false) {
            const skill = isCombo ? COMBOS.find(c => c.id === skillId) : getEffectiveSkill(skillId);
            const p = gameState.player;

            if (attacker === p && !isCombo && p.currentMp < skill.cost) { 
                addLog('MP가 부족합니다!'); 
                isPlayerTurn = true; 
                toggleSkillButtons(false); 
                return; 
            }
            if (attacker === p && !isCombo) {
                p.currentMp -= skill.cost;
            }
            
            const skillLevel = (attacker === p) ? (p.skillLevels[skillId] || 1) : 1;
            const skillName = `${skill.name} ${skillLevel > 1 && !isCombo ? `(Lv.${skillLevel})` : ''}`;
            addLog(`${attacker.name || '플레이어'}의 <span class="font-bold text-yellow-300">${skillName}</span>!`);
            
            const attackerEl = attacker === p ? dom.player.el : dom.enemy.el;
            const defenderEl = defender === p ? dom.player.el : dom.enemy.el;
            
            if (attacker === p) {
                if (selectedClassName === 'mage') {
                    playSpriteAnimation(dom.player.sprite, MAGE_SPRITE_DATA, 'attack', 0.8);
                } else if (selectedClassName === 'rogue') {
                    playSpriteAnimation(dom.player.sprite, ROGUE_SPRITE_DATA, 'attack', 0.6);
                } else if (selectedClassName === 'warrior') {
                    playSpriteAnimation(dom.player.sprite, WARRIOR_SPRITE_DATA, 'attack', 0.8);
                }
            } else {
                 attackerEl.classList.add('attack');
                 setTimeout(() => attackerEl.classList.remove('attack'), 400);
            }
            
            setTimeout(() => {
                const attackerStats = getEffectiveStats(attacker);
                const defenderStats = getEffectiveStats(defender);

                if (skill.type === 'attack') {
                    if (defenderStats.immune) {
                        addLog(`<span class="font-bold text-blue-300">면역!</span> 피해를 받지 않았습니다.`);
                    } else {
                        playSound(skill.vfx);
                        playVFX(defenderEl, skill.vfx, attackerEl);
                        if (attacker === p && skillLevel >= 5) {
                            playSpriteVFX(defenderEl, SUNDER_VFX_DATA, SUNDER_VFX_URL);
                        }
                        let power = 0;
                        const levelMultiplier = 1 + (skillLevel - 1) * 0.2;
                        if (attacker === p) { 
                            power = ((attackerStats.attack * (skill.scale.str || 0)) + (p.stats.int * 2.5 * (skill.scale.int || 0)) + (p.stats.agi * 1.5 * (skill.scale.agi || 0))) * levelMultiplier;
                        } else { 
                            power = attackerStats.attack * (skill.scale || 1.0); 
                        }
                        let damage = Math.floor(Math.max(10, power * (100 / (100 + defenderStats.defense)) * (Math.random() * 0.15 + 0.85)));
                        const isCrit = (attacker === p) && (Math.random() * 100 < attackerStats.critChance);
                        if (isCrit) {
                            damage = Math.floor(damage * (attackerStats.critDamage / 100));
                            addLog(`<span class="font-bold text-yellow-300">치명타!</span>`);
                        }
                        playSound('damage');
                        defender.currentHp = Math.max(0, defender.currentHp - damage);
                        showDamageVFX(defenderEl, `-${damage}`, isCrit);
                        addLog(`<span class="font-bold text-red-400">${defender.name || '플레이어'}</span>에게 ${damage}의 데미지!`, 'text-white');
                        defenderEl.classList.add('take-damage');
                        setTimeout(() => defenderEl.classList.remove('take-damage'), 300);

                        if (attacker === p) {
                            addLog(`경험치 <span class="text-purple-300">10</span> 획득!`, 'text-gray-200');
                            gainXP(10);
                        }
                    }
                } else if (skill.type === 'heal') {
                    playSound(skill.vfx);
                    playVFX(dom.player.el, skill.vfx);
                    const levelMultiplier = 1 + (skillLevel - 1) * 0.2;
                    const heal = Math.floor(p.stats.int * 5 * (skill.scale.int || 1) * levelMultiplier);
                    p.currentHp = Math.min(p.maxHp, p.currentHp + heal);
                    showDamageVFX(dom.player.el, `+${heal}`, false);
                    addLog(`<span class="font-bold text-green-400">플레이어</span>의 체력이 ${heal} 회복되었다!`, 'text-white');
                } else if (skill.type === 'buff') {
                    playSound(skill.vfx);
                    playVFX(attackerEl, skill.vfx);
                    attacker.activeBuffs.push({ id: skillId, duration: skill.duration });
                }
                
                updateAllUI();
                checkBattleOver();

                if (!isBattleOver && !isCombo) { 
                    if (attacker === p) {
                        checkCombos(skillId);
                        setTimeout(enemyTurn, 1000);
                    } else { 
                        isPlayerTurn = true; 
                        toggleSkillButtons(false); 
                    } 
                }
            }, 400);
        }

        function checkCombos(lastSkillId) {
            const p = gameState.player;
            p.comboHistory.push(lastSkillId);
            if (p.comboHistory.length > 2) p.comboHistory.shift();
            if (p.comboHistory.length === 2) {
                const combo = COMBOS.find(c => c.skills[0] === p.comboHistory[0] && c.skills[1] === p.comboHistory[1]);
                if (combo) {
                    addLog(`<span class="font-bold text-purple-400">콤보 발동!</span>`);
                    performAction(p, enemy, combo.id, true);
                    p.comboHistory = []; 
                }
            }
        }

        function checkBattleOver() { if (gameState.player.currentHp <= 0) handleDefeat(); else if (enemy.currentHp <= 0) handleVictory(); }
        
        function tickBuffs(character) {
            character.activeBuffs.forEach(buff => {
                buff.duration--;
                if (buff.duration <= 0) {
                    addLog(`<span class="font-bold">${character.name || '플레이어'}</span>의 ${SKILLS[buff.id].name} 효과가 사라졌다.`);
                }
            });
            character.activeBuffs = character.activeBuffs.filter(buff => buff.duration > 0);
            updateAllUI();
        }

        function playerTurn(skillId) { 
            if (!isPlayerTurn || isBattleOver) return; 
            
            tickBuffs(gameState.player);
            
            const regenPercent = gameState.player.regen_percent;
            const hpRegen = Math.floor(gameState.player.maxHp * regenPercent);
            const mpRegen = Math.floor(gameState.player.maxMp * regenPercent);
            if ((hpRegen > 0 || mpRegen > 0) && gameState.player.currentHp > 0) {
                gameState.player.currentHp = Math.min(gameState.player.maxHp, gameState.player.currentHp + hpRegen);
                gameState.player.currentMp = Math.min(gameState.player.maxMp, gameState.player.currentMp + mpRegen);
                addLog(`자연 치유로 HP <span class="text-green-400">${hpRegen}</span>, MP <span class="text-blue-400">${mpRegen}</span> 회복!`, 'text-gray-200');
            }

            isPlayerTurn = false; 
            toggleSkillButtons(true);
            performAction(gameState.player, enemy, skillId);
        }

        function enemyTurn() { 
            if (isBattleOver) return; 
            tickBuffs(enemy);
            const randomSkill = enemy.skills[Math.floor(Math.random() * enemy.skills.length)]; 
            performAction(enemy, gameState.player, randomSkill.id); 
        }

        function toggleSkillButtons(disabled) { dom.controls.skills.querySelectorAll('button').forEach(btn => btn.disabled = disabled); }
        
        function openModal(modalName) { if(dom.modals[modalName]) dom.modals[modalName].classList.remove('hidden'); }
        function closeModal(modalName) { if(dom.modals[modalName]) dom.modals[modalName].classList.add('hidden'); }

        function openCharModal() {
            tempStats = {
                stats: { ...gameState.player.stats },
                statPoints: gameState.player.statPoints
            };
            initialStats = { ...gameState.player.stats };
            updateCharModalUI();
            openModal('character');
        }

        function updateCharModalUI() {
            const p = { ...gameState.player, ...tempStats };
            const derived = applyPassiveEffects(p);

            dom.charModal.points.textContent = p.statPoints;
            dom.charModal.str.textContent = Math.round(p.stats.str);
            dom.charModal.int.textContent = Math.round(p.stats.int);
            dom.charModal.agi.textContent = Math.round(p.stats.agi);
            dom.charModal.vit.textContent = Math.round(p.stats.vit);
            dom.charModal.luk.textContent = Math.round(p.stats.luk);

            dom.charModal.atk.textContent = Math.round(derived.attack);
            dom.charModal.def.textContent = Math.round(derived.defense);
            dom.charModal.hp.textContent = Math.round(derived.maxHp);
            dom.charModal.mp.textContent = Math.round(derived.maxMp);
            dom.charModal.critChance.textContent = derived.critChance.toFixed(1);
            dom.charModal.critDamage.textContent = derived.critDamage.toFixed(1);
        }

        dom.modals.character.addEventListener('click', e => {
            const target = e.target.closest('.stat-btn');
            if (!target) return;
            const stat = target.dataset.stat;
            if (target.classList.contains('plus-btn')) {
                if (tempStats.statPoints > 0) {
                    tempStats.stats[stat]++;
                    tempStats.statPoints--;
                }
            } else if (target.classList.contains('minus-btn')) {
                if (tempStats.stats[stat] > initialStats[stat]) {
                    tempStats.stats[stat]--;
                    tempStats.statPoints++;
                }
            }
            updateCharModalUI();
        });

        dom.charModal.confirmBtn.addEventListener('click', () => {
            const oldStats = applyPassiveEffects(gameState.player);
            const hpRatio = gameState.player.currentHp / oldStats.maxHp;
            const mpRatio = gameState.player.currentMp / oldStats.maxMp;
            
            gameState.player.stats = tempStats.stats;
            gameState.player.statPoints = tempStats.statPoints;
            
            const newStats = applyPassiveEffects(gameState.player);
            gameState.player.currentHp = newStats.maxHp * hpRatio;
            gameState.player.currentMp = newStats.maxMp * mpRatio;
            
            updateAllUI();
            closeModal('character');
        });

        function openSkillModal() { 
            updateSkillModal(); 
            openModal('skillTree'); 
            dom.skillModal.tabs.querySelector('button:not(#combo-tab-btn):not(#passive-tab-btn)')?.click();
        }

        function updateSkillModal() {
            dom.skillModal.points.textContent = gameState.player.skillPoints;
            dom.skillModal.passivePoints.textContent = gameState.player.passiveSkillPoints;
            dom.skillModal.detailsPanel.innerHTML = '';
            if (dom.skillModal.tabs.innerHTML === '') {
                // Active Skill Trees
                Object.keys(SKILL_TREES).forEach((key) => {
                    const tab = document.createElement('button');
                    tab.className = 'p-2 text-gray-400 hover:text-white';
                    tab.textContent = SKILL_TREES[key].name;
                    tab.onclick = () => {
                        document.querySelectorAll('#skill-tree-tabs button').forEach(b => b.classList.remove('text-yellow-300', 'border-b-2', 'border-yellow-300'));
                        tab.classList.add('text-yellow-300', 'border-b-2', 'border-yellow-300');
                        renderSkillList(key, 'active');
                    };
                    dom.skillModal.tabs.appendChild(tab);
                });
                // Passive Tab
                const passiveTab = document.createElement('button');
                passiveTab.id = 'passive-tab-btn';
                passiveTab.className = 'p-2 text-gray-400 hover:text-white';
                passiveTab.textContent = '패시브';
                passiveTab.onclick = () => {
                    document.querySelectorAll('#skill-tree-tabs button').forEach(b => b.classList.remove('text-yellow-300', 'border-b-2', 'border-yellow-300'));
                    passiveTab.classList.add('text-yellow-300', 'border-b-2', 'border-yellow-300');
                    renderSkillList(selectedClassName, 'passive');
                };
                dom.skillModal.tabs.appendChild(passiveTab);

                // Combo Tab
                const comboTab = document.createElement('button');
                comboTab.id = 'combo-tab-btn';
                comboTab.className = 'p-2 text-gray-400 hover:text-white';
                comboTab.textContent = '콤보';
                comboTab.onclick = () => {
                    document.querySelectorAll('#skill-tree-tabs button').forEach(b => b.classList.remove('text-yellow-300', 'border-b-2', 'border-yellow-300'));
                    comboTab.classList.add('text-yellow-300', 'border-b-2', 'border-yellow-300');
                    renderSkillList(null, 'combo');
                };
                dom.skillModal.tabs.appendChild(comboTab);
            }
            renderEquippedSkills();
        }
        
        function renderSkillList(key, type) {
            const listPanel = dom.skillModal.listPanel;
            listPanel.innerHTML = '';
            dom.skillModal.detailsPanel.innerHTML = '';

            let skillsToList = [];
            if (type === 'active') {
                skillsToList = SKILL_TREES[key].skills.flat();
            } else if (type === 'passive') {
                skillsToList = Object.keys(PASSIVE_SKILLS[key]);
            } else if (type === 'combo') {
                skillsToList = COMBOS.map(c => c.id);
            }

            skillsToList.forEach(skillId => {
                const isPassive = type === 'passive';
                const isCombo = type === 'combo';
                const skillData = isPassive ? PASSIVE_SKILLS[key][skillId] : (isCombo ? COMBOS.find(c => c.id === skillId) : SKILLS[skillId]);
                if (!skillData) return;

                const item = document.createElement('div');
                item.className = 'skill-list-item';
                item.dataset.skillId = skillId;
                item.dataset.type = type;
                item.dataset.key = key;

                const iconName = isCombo ? SKILLS[skillData.skills[1]].icon : skillData.icon;
                const sprite = spriteData.sprites.find(s => s.name === iconName);
                const SPRITE_SCALE_FACTOR = 6.0;
                const scaledWidth = spriteData.meta.size.w / SPRITE_SCALE_FACTOR;
                const scaledHeight = spriteData.meta.size.h / SPRITE_SCALE_FACTOR;
                const scaledX = sprite.x / SPRITE_SCALE_FACTOR;
                const scaledY = sprite.y / SPRITE_SCALE_FACTOR;
                
                const level = isPassive ? (gameState.player.passiveSkills[skillId] || 0) : (gameState.player.skillLevels[skillId] || 0);
                const levelText = isCombo ? '콤보' : (level > 0 ? `Lv. ${level}` : '미습득');

                item.innerHTML = `
                    <div class="icon-container rounded-md overflow-hidden border border-gray-600">
                        <div class="skill-sprite-icon w-full h-full" style="background-image: url('${SPRITE_IMAGE_URL}'); background-size: ${scaledWidth}px ${scaledHeight}px; background-position: -${scaledX}px -${scaledY}px;"></div>
                    </div>
                    <div>
                        <p class="font-bold">${skillData.name}</p>
                        <p class="text-xs text-gray-400">${levelText}</p>
                    </div>
                `;
                item.onclick = () => {
                    document.querySelectorAll('.skill-list-item').forEach(i => i.classList.remove('selected'));
                    item.classList.add('selected');
                    if (isPassive) {
                        showPassiveUpgradePanel(skillId);
                    } else if (isCombo) {
                        showComboDetailsPanel(skillId);
                    } else {
                        showUpgradePanel(skillId, key);
                    }
                };
                listPanel.appendChild(item);
            });
        }

        function showUpgradePanel(skillId) {
            const detailsPanel = dom.skillModal.detailsPanel;
            const skill = SKILLS[skillId];
            const p = gameState.player;
            const currentLevel = p.skillLevels[skillId] || 0;
            const isLearned = currentLevel > 0;
            const canLearn = p.skillPoints > 0 && (!skill.requires || p.learnedSkills.includes(skill.requires));

            let html = `<h4 class="font-bold text-lg text-yellow-300 mb-2">${skill.name} ${isLearned ? `(Lv.${currentLevel})` : ''}</h4>`;
            html += `<p class="text-sm text-gray-300 mb-4">${skill.desc}</p>`;
            
            if (skill.requires && !p.learnedSkills.includes(skill.requires)) {
                html += `<p class="text-sm text-red-400 mb-2">선행 스킬: ${SKILLS[skill.requires].name} 필요</p>`;
            }

            // Buttons
            const buttons = [];
            if (!isLearned) {
                buttons.push(`<button id="learn-skill-btn" class="game-button text-sm py-2 px-4" ${!canLearn ? 'disabled' : ''}>배우기 (1 SP)</button>`);
            } else {
                buttons.push(`<button id="upgrade-skill-btn" class="game-button text-sm py-2 px-4" ${p.skillPoints < 1 ? 'disabled' : ''}>강화 (1 SP)</button>`);
                
                const isEquipped = p.equippedSkills.includes(skillId);
                if (isEquipped) {
                    buttons.push(`<button id="unequip-skill-btn" class="game-button text-sm py-2 px-4">해제</button>`);
                } else {
                    const hasEmptySlot = p.equippedSkills.includes(null);
                    buttons.push(`<button id="equip-skill-btn" class="game-button text-sm py-2 px-4" ${!hasEmptySlot ? 'disabled' : ''}>장착</button>`);
                }
            }
            html += `<div class="flex gap-2 mt-4">${buttons.join('')}</div>`;
            detailsPanel.innerHTML = html;

            // Event Listeners
            document.getElementById('learn-skill-btn')?.addEventListener('click', () => {
                p.skillPoints--;
                p.skillLevels[skillId] = 1;
                p.learnedSkills.push(skillId);
                updateSkillModal();
                showUpgradePanel(skillId); // Refresh panel
            });
            document.getElementById('upgrade-skill-btn')?.addEventListener('click', () => {
                p.skillPoints--;
                p.skillLevels[skillId]++;
                updateSkillModal();
                showUpgradePanel(skillId); // Refresh panel
            });
            document.getElementById('equip-skill-btn')?.addEventListener('click', () => {
                const emptySlotIndex = p.equippedSkills.findIndex(s => s === null);
                if (emptySlotIndex !== -1) {
                    p.equippedSkills[emptySlotIndex] = skillId;
                    updateSkillModal();
                    setupSkillButtons();
                    showUpgradePanel(skillId); // Refresh panel
                }
            });
            document.getElementById('unequip-skill-btn')?.addEventListener('click', () => {
                const slotIndex = p.equippedSkills.findIndex(s => s === skillId);
                if (slotIndex !== -1) {
                    unequipSkillFromSlot(slotIndex);
                    updateSkillModal();
                    showUpgradePanel(skillId); // Refresh panel
                }
            });
        }

        function showPassiveUpgradePanel(skillId) {
            const detailsPanel = dom.skillModal.detailsPanel;
            const skill = PASSIVE_SKILLS[selectedClassName][skillId];
            const p = gameState.player;
            const currentLevel = p.passiveSkills[skillId] || 0;
            const isMaxLevel = currentLevel >= skill.maxLevel;
            const canUpgrade = p.passiveSkillPoints > 0 && !isMaxLevel;

            let html = `<h4 class="font-bold text-lg text-yellow-300 mb-2">${skill.name} (Lv.${currentLevel}/${skill.maxLevel})</h4>`;
            html += `<p class="text-sm text-gray-300 mb-2">현재 효과: ${currentLevel > 0 ? skill.desc(currentLevel) : '없음'}</p>`;
            if (!isMaxLevel) {
                html += `<p class="text-sm text-green-400 mb-4">다음 레벨: ${skill.desc(currentLevel + 1)}</p>`;
            }
            
            html += `<button id="upgrade-passive-btn" class="game-button text-sm py-2 px-4" ${!canUpgrade ? 'disabled' : ''}>강화 (1 PSP)</button>`;
            detailsPanel.innerHTML = html;

            document.getElementById('upgrade-passive-btn')?.addEventListener('click', () => {
                p.passiveSkillPoints--;
                p.passiveSkills[skillId] = (p.passiveSkills[skillId] || 0) + 1;
                updateSkillModal();
                showPassiveUpgradePanel(skillId); // Refresh panel
            });
        }
        
        function showComboDetailsPanel(comboId) {
            const detailsPanel = dom.skillModal.detailsPanel;
            const combo = COMBOS.find(c => c.id === comboId);
            const skill1 = SKILLS[combo.skills[0]];
            const skill2 = SKILLS[combo.skills[1]];
            detailsPanel.innerHTML = `
                <h4 class="font-bold text-lg text-purple-400 mb-2">${combo.name}</h4>
                <p class="text-sm mb-2">조건: ${skill1.name} → ${skill2.name}</p>
                <p class="text-xs text-gray-400">효과: ${combo.desc}</p>
            `;
        }
        
        function renderEquippedSkills() {
            const container = dom.skillModal.equippedSkills;
            container.innerHTML = '<h3 class="text-xl font-bold mb-2 text-center">장착된 스킬</h3><div class="flex justify-center gap-2 flex-wrap"></div>';
            const grid = container.querySelector('div');
            const equipped = ['basic_attack', ...gameState.player.equippedSkills];
            for(let i=0; i < 11; i++){
                const skillId = equipped[i];
                const slot = document.createElement('div');
                slot.className = 'w-16 h-16 bg-gray-900 border border-gray-600 rounded-lg flex items-center justify-center cursor-pointer';
                if(skillId){
                    const skill = SKILLS[skillId];
                    const sprite = spriteData.sprites.find(s => s.name === skill.icon);
                    const SPRITE_SCALE_FACTOR = 4.0;
                    const scaledWidth = spriteData.meta.size.w / SPRITE_SCALE_FACTOR;
                    const scaledHeight = spriteData.meta.size.h / SPRITE_SCALE_FACTOR;
                    const scaledX = sprite.x / SPRITE_SCALE_FACTOR;
                    const scaledY = sprite.y / SPRITE_SCALE_FACTOR;
                    slot.innerHTML = `<div class="w-12 h-12 overflow-hidden rounded"><div class="skill-sprite-icon" style="background-image: url('${SPRITE_IMAGE_URL}'); background-size: ${scaledWidth}px ${scaledHeight}px; background-position: -${scaledX}px -${scaledY}px;"></div></div>`;
                    if (i > 0) { // Basic attack cannot be unequipped
                        slot.onclick = () => {
                            unequipSkillFromSlot(i - 1);
                            updateSkillModal();
                            dom.skillModal.tabs.querySelector('.text-yellow-300').click(); // Re-render current tab
                        };
                    }
                }
                grid.appendChild(slot);
            }
        }

        function renderComboList() {
            const listPanel = dom.skillModal.listPanel;
            listPanel.innerHTML = '';
            dom.skillModal.detailsPanel.innerHTML = '';
            COMBOS.forEach(combo => {
                const item = document.createElement('div');
                item.className = 'skill-list-item';
                item.innerHTML = `<p class="font-bold text-purple-400">${combo.name}</p>`;
                item.onclick = () => {
                     document.querySelectorAll('.skill-list-item').forEach(i => i.classList.remove('selected'));
                    item.classList.add('selected');
                    const skill1 = SKILLS[combo.skills[0]];
                    const skill2 = SKILLS[combo.skills[1]];
                    dom.skillModal.detailsPanel.innerHTML = `
                        <h4 class="font-bold text-lg text-yellow-300 mb-2">${combo.name}</h4>
                        <p class="text-sm mb-2">조건: ${skill1.name} → ${skill2.name}</p>
                        <p class="text-xs text-gray-400">효과: ${combo.desc}</p>
                    `;
                };
                listPanel.appendChild(item);
            });
        }

        function updateMenuButtonsNotification() {
            const charBtn = document.getElementById('char-menu-btn');
            const skillBtn = document.getElementById('skill-menu-btn');
            if (gameState.player && gameState.player.statPoints > 0) {
                charBtn.classList.add('has-points');
            } else {
                charBtn.classList.remove('has-points');
            }
            if (gameState.player && (gameState.player.skillPoints > 0 || gameState.player.passiveSkillPoints > 0)) {
                skillBtn.classList.add('has-points');
            } else {
                skillBtn.classList.remove('has-points');
            }
        }

        function preloadImages(urls) {
            const promises = urls.map(url => new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = resolve;
                img.onerror = reject;
                img.src = url;
            }));
            return Promise.all(promises);
        }

        function addClickSounds() {
            document.querySelectorAll('.game-button, .menu-btn, .class-card, .skill-card, .stat-btn, .skill-node, #skill-tree-tabs button').forEach(el => {
                el.addEventListener('click', () => playSound('click'));
            });
        }

        dom.screens.title.querySelector('#start-game-btn').addEventListener('click', async () => {
             await Tone.start();
             setupSounds();
             addClickSounds();
             switchScreen('classSelection');
             document.getElementById('bgm').play().catch(e => console.log("BGM auto-play failed."));
        });
        dom.screens.classSelection.addEventListener('click', (e) => { const card = e.target.closest('.class-card'); if (card) { showSkillSelection(card.dataset.class); } });
        dom.skillSelection.confirmBtn.addEventListener('click', showPassiveSkillSelection);
        dom.passiveSkillSelection.confirmBtn.addEventListener('click', startGame);
        dom.screens.gameOver.querySelector('#restart-game-btn').addEventListener('click', () => location.reload());
        dom.screens.gameClear.querySelector('#play-again-btn').addEventListener('click', () => location.reload());
        dom.screens.stageClear.querySelector('#next-stage-btn').addEventListener('click', () => { gameState.currentStage++; if (gameState.currentStage >= STAGES.length) { switchScreen('gameClear'); } else { switchScreen('battle'); loadStage(gameState.currentStage); } });
        document.getElementById('char-menu-btn').addEventListener('click', () => { dom.modals.character.classList.contains('hidden') ? openCharModal() : closeModal('character'); });
        document.getElementById('skill-menu-btn').addEventListener('click', () => { dom.modals.skillTree.classList.contains('hidden') ? openSkillModal() : closeModal('skillTree'); });
        dom.modals.character.querySelector('#close-char-modal').addEventListener('click', () => closeModal('character'));
        dom.modals.skillTree.querySelector('#close-skill-modal').addEventListener('click', () => closeModal('skillTree'));
        
        async function initializeGame() {
            const imageUrls = [
                SPRITE_IMAGE_URL,
                MAGE_SPRITE_URL,
                ROGUE_SPRITE_URL,
                WARRIOR_SPRITE_URL,
                SUNDER_VFX_URL,
                'https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/file_00000000497c61fa963025bb3510d7bb_copy_1152x768.webp',
                ...STAGES.map(stage => stage.img),
                bossBg
            ];
            try {
                await preloadImages(imageUrls);
                switchScreen('title');
            } catch (error) {
                console.error("Image loading failed:", error);
                document.getElementById('loading-screen').innerHTML = '<p>이미지를 불러오는 데 실패했습니다. 페이지를 새로고침 해주세요.</p>';
            }
        }

        initializeGame();
    </script>
</body>
</html>
